[{"title":"梆梆加固分析(一)","url":"/2025/04/09/bangbang_protect_1/","content":"java层JAVA层的代码量不多, 在attachBaseContext 方法中调用了load方法，具体是加载了一个名为DexHelper的动态库。\n\n\ndoAttach方法使用反射调用了app的代码。说明在加载DexHelper后就已经完成了DEX的释放。接下来分析DexHelper.so\n\n修复DexHelper.so\nIDA打开后可以很明显的看到文件代码段被加密了。.init_proc会在so被加载时执行并完成文件的解密，所以我们只需要HOOK dlopen将DexHelper给dump下来就能得到解密后的so。（也可以调试让程序执行.init_proc然后dump）。\n//frida -U -f &quot;com.chaoxing.mobile&quot; -l dump.jsfunction hook_dlopen()&#123;    var filename = &quot;libDexHelper.so&quot;;    Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;), &#123;        onEnter: function(args) &#123;            if(args[0] != null)&#123;                console.log(&#x27;dlopen called with filename: &#x27; + Memory.readUtf8String(args[0]));                let filepath = Memory.readUtf8String(args[0])                if(filepath.includes(filename))&#123;                   this.loaded = 1;                &#125;            &#125;        &#125;,        onLeave: function(retval)&#123;            console.log(&quot;return&quot;)            if(this.loaded == 1)&#123;                dump_so(filename);                this.loaded = 0;            &#125;            return retval;      &#125;    &#125;    );&#125;function dump_so(filename)&#123;    var handle = Process.getModuleByName(filename);    console.log(&quot;[dumping...........]&quot;);    var path = &quot;/data/data/com.chaoxing.mobile/&quot; + handle.name + &quot;_&quot; + handle.base + &quot;_&quot; + ptr(handle.size) + &quot;.so&quot;;    var file_handle = new File(path, &quot;wb&quot;);    if(!file_handle) &#123;        console.log(&quot;[dump] failed to open file&quot;);    &#125;        Memory.protect(ptr(handle.base), handle.size, &#x27;rwx&#x27;);        var libbuffer = ptr(handle.base).readByteArray(handle.size);        file_handle.write(libbuffer);        file_handle.close();        console.log(&quot;[dump] finished path is &quot; + path);    &#125;setImmediate(hook_dlopen);\n\n然后修复一下ELF文件，我使用了https://github.com/Chenyangming9/SoFixer#。\n\nJNI_OnLoad文件的函数名很多都被混淆了，可以写个idapython脚本恢复函数名。\nimport idautilsimport idcdef rename_functions():    for func_ea in idautils.Functions():        old_name = idc.get_func_name(func_ea)        if old_name.startswith(&quot;pS&quot;) or old_name.startswith(&quot;p5&quot;) or old_name.startswith(&quot;5&quot;) or old_name.startswith(&quot;S&quot;):            new_name = f&quot;sub_&#123;func_ea:X&#125;&quot;        else:            continue  # 不是混淆函数名，跳过        if idc.set_name(func_ea, new_name, idc.SN_NOWARN):            print(f&quot;[+] Renamed: &#123;old_name&#125; -&gt; &#123;new_name&#125; (0x&#123;func_ea:X&#125;)&quot;)# 运行脚本rename_functions()\n\n初始化部分JNI_OnLoad首先注册了一些Native方法，接着对设备运行的环境，包括android版本，android虚拟机类型等进行了一系列的检测。\ncom/secneo/apkwrapper/H    (Ljava/lang/String;)I  he    (Ljava/lang/String;I)V gha    (I)V sha    (Ljava/lang/String;)Ljava/lang/String; dcom/secneo/apkwrapper/AW    (Landroid/content/Context;Landroid/app/Application;)V hn    ()V pn\n\nsub_31278这个函数是加固的核心函数，包括了对libc的hook , 反调试和检测，以及对dex文件的解密等。\n检测分析sub_430C0的函数对libc.so进行了hook,主要hook了read,open,write,mmap等函数。\nsub_4C908中位于偏移0x52BC4的函数向frida-server发送AUTH\\r\\n，检测REJECT。\n\nsub_4CB6C中实现了对环境的检测。包括对root权限，magisk, su等的检测。\n\n之后pthread_create创建了一个线程，函数sub_52EA0 fork了一个子进程并且通过execl启动Java层的检测，主要检测了&#x2F;proc&#x2F;pid&#x2F;status&#x3D;&#x3D;&gt;TracerPid。\n\nsub_4D638函数实现了对hook框架，CLASSPATH的检测，通过对比libart.so中导出函数的前16字节判断是否被修改。\n\nsub_4E308函数主要负责检测虚拟环境，模拟器等。\n\n\n调试器检测主要通过sub_56C10函数来实现，检测&#x2F;proc&#x2F;pid&#x2F;status目录下的TracerPid是否为pid和State字段是否T (stopped)。\n\nDEX文件解密被加密的数据位于最大的dex中，以dexdata0作为标志。搜索dexdata0可以定位到解密并释放Dex的函数。函数偏移为0x3199C.\n\n\n解密函数位于偏移0x38E04，这里会循环解密dex数据。每次申请了0x20000大小的空间，然后将解密后的数据放在其中。解密函数的三个参数分别是密文，解密数据，密钥。事实上在这里就可以dump获取解密的dex文件了。\n\n接着会调用makeInMemoryDexElements，它的作用是将内存中的 DEX 数据（如一个 ByteBuffer 数组）转换为可被类加载器使用的 DexPathList.Element 数组  。\n\n最后调用DexFileLoader::Load加载Dex。\n\n总结：\n简单地分析了这个加固的样本，主要关注了壳的检测部分以及dex文件的解密部分，第一次分析企业版加固，应该还有很多地方没有分析到，VMP的代码位于libdexjni.so，奈何对vmp的了解不多，只能暂时搁置。\n参考：\nhttps://www.cnblogs.com/2014asm/p/14547218.html 梆梆APP加固产品方案浅析\nhttps://bbs.kanxue.com/thread-280513.htm 脱壳纪事——梆梆企业版（一）\n","categories":["逆向"],"tags":["脱壳","android"]},{"title":"android中so的加载(一)","url":"/2025/04/15/android_load_so1/","content":"loadLibraryJava层使用System.LoadLibrary或System.Load来加载so文件。源码位于&#x2F;libcore&#x2F;ojluni&#x2F;src&#x2F;main&#x2F;java&#x2F;java&#x2F;lang&#x2F;Runtime.java (这里主要参考了android10的源码)\n这两种方式的区别在于，System.load的参数为libpath，直接传入so路径加载。而System.LoadLibrary的参数为libname，需要先查找路径再进行加载。\npublic static void load(String filename) &#123;    Runtime.getRuntime().load0(Reflection.getCallerClass(), filename);&#125;public static void loadLibrary(String libname) &#123;    Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);&#125;\n\nloadLibrary0private synchronized void loadLibrary0(ClassLoader loader, Class&lt;?&gt; callerClass, String libname) &#123;      if (libname.indexOf((int)File.separatorChar) != -1) &#123;          throw new UnsatisfiedLinkError(  &quot;Directory separator should not appear in library name: &quot; + libname);      &#125;      String libraryName = libname;        if (loader != null &amp;&amp; !(loader instanceof BootClassLoader)) &#123;          //loader不为空          String filename = loader.findLibrary(libraryName);          //获取动态库路径          if (filename == null) &#123;                            throw new UnsatisfiedLinkError(loader + &quot; couldn&#x27;t find \\&quot;&quot; +                                             System.mapLibraryName(libraryName) + &quot;\\&quot;&quot;);          &#125;          String error = nativeLoad(filename, loader);          if (error != null) &#123;              throw new UnsatisfiedLinkError(error);          &#125;          return;      &#125;      //loader为空      getLibPaths();             String filename = System.mapLibraryName(libraryName);      String error = nativeLoad(filename, loader, callerClass);      if (error != null) &#123;          throw new UnsatisfiedLinkError(error);      &#125;  &#125;\n\nloadLibrary0会判断ClassLoader是否为空，当ClassLoader为不为空时会通过findLibrary来获取完整路径，当ClassLoader为空时则会通过getLIbPaths来获取。最后通过nativeLoad来加载。\n\nprotected String findLibrary(String libname) &#123;   return null;&#125;\n\nClassLoader中的findLibrary为空，要知道是使用的是哪个ClassLoader可以在程序中打印ClassLoader，发现运行的是PathClassLoader。同时还输出了nativeLibraryDirectories，很明显这就是加载so时查找的路径,它是怎么来的呢，先继续往下看。\n\nnativeLibraryDirectories=[        /data/app/com.example.loadso-T289WyOMZa9KcrBp8H3Fbw==/lib/arm64,         /data/app/com.example.loadso-T289WyOMZa9KcrBp8H3Fbw==/base.apk!/lib/arm64-v8a,         /system/lib64,         /vendor/lib64,         /system/product/lib64]]]\n\nPathClassLoader继承自BaseDexClassLoader。\n//PathCLassLoader.javapublic PathClassLoader(String dexPath, String librarySearchPath, ClassLoader parent) &#123;      super(dexPath, null, librarySearchPath, parent); &#125;//BaseDexClassLoader.javapublic BaseDexClassLoader(String dexPath,              String librarySearchPath, ClassLoader parent, ClassLoader[] sharedLibraryLoaders,              boolean isTrusted) &#123;          super(parent);          // Setup shared libraries before creating the path list. ART relies on the class loader          // hierarchy being finalized before loading dex files.          this.sharedLibraryLoaders = sharedLibraryLoaders == null                  ? null                  : Arrays.copyOf(sharedLibraryLoaders, sharedLibraryLoaders.length);          this.pathList = new DexPathList(this, dexPath, librarySearchPath, null, isTrusted);            if (reporter != null) &#123;              reportClassLoaderChain();          &#125;      &#125;\n\nBaseDexClassLoader使用librarySearchPath初始化了一个DexPathList对象。调用的findLibrary是DexPathList的findLibrary方法。\n//BaseDexlassLoader.javapublic String findLibrary(String name) &#123;          return pathList.findLibrary(name);&#125;//DexPathList.javapublic String findLibrary(String libraryName) &#123;    //获取完整文件名  String fileName = System.mapLibraryName(libraryName);  for (NativeLibraryElement element : nativeLibraryPathElements) &#123;      String path = element.findNativeLibrary(fileName);      if (path != null) &#123;          return path;      &#125;  &#125;  return null;&#125;\n\n同时toString方法也是DexPathList对象的toString方法。也就是说前面输出的是nativeLibraryDirectories和systemNativeLibraryDirectories合并后的路径列表。接下来分析它们分别是什么。\n//baseDexClassLoader.java@Override public String toString() &#123;  return getClass().getName() + &quot;[&quot; + pathList + &quot;]&quot;;&#125;//DexPathList.java@Override public String toString() &#123;  return &quot;DexPathList[&quot; + Arrays.toString(dexElements) +      &quot;,nativeLibraryDirectories=&quot; +      Arrays.toString(getAllNativeLibraryDirectories().toArray()) + &quot;]&quot;;&#125;private List&lt;File&gt; getAllNativeLibraryDirectories() &#123;  List&lt;File&gt; allNativeLibraryDirectories = new ArrayList&lt;&gt;(nativeLibraryDirectories);  allNativeLibraryDirectories.addAll(systemNativeLibraryDirectories);  return allNativeLibraryDirectories;&#125;\n\n在DexPathList的构造方法中，librarySearchPath是通过ClassLoader传入的APP自己的so路径，将它赋值给了nativeLibraryDirectories，接着获取了系统默认的搜索路径java.library.path，将它赋值给systemNativeLibraryDirectories，最后将它们组合起来。到这里就能够解释toString方法的输出了。\n//DexPathList.javaDexPathList(ClassLoader definingContext, String dexPath,            String librarySearchPath, File optimizedDirectory, boolean isTrusted) &#123;    ........................    ........................    this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,                                       suppressedExceptions, definingContext, isTrusted);    this.nativeLibraryDirectories = splitPaths(librarySearchPath, false);    this.systemNativeLibraryDirectories =            splitPaths(System.getProperty(&quot;java.library.path&quot;), true);    //获取系统默认加载路径    this.nativeLibraryPathElements = makePathElements(getAllNativeLibraryDirectories());    //合并    if (suppressedExceptions.size() &gt; 0) &#123;        this.dexElementsSuppressedExceptions =            suppressedExceptions.toArray(new IOException[suppressedExceptions.size()]);    &#125; else &#123;        dexElementsSuppressedExceptions = null;    &#125;&#125;\n\n到这里已经清楚so加载的路径是哪些了，但是还有两个问题不太清楚。\n\nDexPathList构造器中获取了java.library.path属性的值，它的值是怎么来的？\n\nSystem_specialProperties中会读取环境变量LD_LIBRARY_PATH的值，若为空则调用android_get_LD_LIBRARY_PATH，最后将其赋值给java.library.path。\n///libcore/ojluni/src/main/native/System.cstatic jobjectArray System_specialProperties(JNIEnv* env, jclass ignored) &#123;    .......    .......    const char* library_path = getenv(&quot;LD_LIBRARY_PATH&quot;);#if defined(__ANDROID__)    if (library_path == NULL) &#123;        android_get_LD_LIBRARY_PATH(path, sizeof(path));        library_path = path;    &#125;#endif    if (library_path == NULL) &#123;        library_path = &quot;&quot;;    &#125;    char* java_path = malloc(strlen(&quot;java.library.path=&quot;) + strlen(library_path) + 1);    strcpy(java_path, &quot;java.library.path=&quot;);    strcat(java_path, library_path);    jstring java_path_str = (*env)-&gt;NewStringUTF(env, java_path);    free((void*)java_path);    if ((*env)-&gt;ExceptionCheck(env)) &#123;        return NULL;    &#125;    (*env)-&gt;SetObjectArrayElement(env, result, 3, java_path_str);    if ((*env)-&gt;ExceptionCheck(env)) &#123;        return NULL;    &#125;    return result;&#125;\n\nandroid_get_LD_LIBRARY_PATH中的do_android_get_LD_LIBRARY_PATH方法会将系统默认的库路径拼接后写入buffer。\nvoid do_android_get_LD_LIBRARY_PATH(char* buffer, size_t buffer_size) &#123;    const auto&amp; default_ld_paths = g_default_namespace.get_default_library_paths();    size_t required_size = 0;    for (const auto&amp; path : default_ld_paths) &#123;        required_size += path.size() + 1;    &#125;    if (buffer_size &lt; required_size) &#123;        async_safe_fatal(&quot;android_get_LD_LIBRARY_PATH failed, buffer too small: &quot;                         &quot;buffer len %zu, required len %zu&quot;, buffer_size, required_size);    &#125;    char* end = buffer;    for (size_t i = 0; i &lt; default_ld_paths.size(); ++i) &#123;        if (i &gt; 0) *end++ = &#x27;:&#x27;;        end = stpcpy(end, default_ld_paths[i].c_str());    &#125;&#125;\n\n\nlibraryPath是app自身的so路径，它是通过ClassLoader传进来的，它又是怎么来的？\n\npublic ClassLoader getClassLoader() &#123;    synchronized(this) &#123;        //...        final ArrayList &lt; String &gt; libPaths = new ArrayList &lt; &gt;();        //...        libPaths.add(mLibDir);\t\t//...        final String lib = TextUtils.join(File.pathSeparator, libPaths);\t\t//...        mClassLoader = ApplicationLoaders.getDefault().getClassLoader(zip, lib, mBaseClassLoader);\t\t//...    &#125;&#125;public LoadedApk(ActivityThread activityThread, ApplicationInfo aInfo, CompatibilityInfo compatInfo, ClassLoader baseLoader, boolean securityViolation, boolean includeCode, boolean registerPackage) &#123;   //...    mLibDir = aInfo.nativeLibraryDir;   //...&#125;\n\n libraryPath来自 app 的 ApplicationInfo 中的 nativeLibraryDir 变量。根据app启动的流程， app 的 ApplicationInfo 信息，包括 nativeLibraryDir 都可以在 data&#x2F;system&#x2F;packages.xml 中查到。\n参考：\nhttps://www.cnblogs.com/dasusu/p/9810673.html \nhttps://juejin.cn/post/6844903993668272141\n","categories":["Android"],"tags":["android","linux","AOSP"]}]