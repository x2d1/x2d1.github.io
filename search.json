[{"title":"android中so的加载(一)","url":"/2025/04/15/android_load_so1/","content":"loadLibraryJava层使用System.LoadLibrary或System.Load来加载so文件。源码位于&#x2F;libcore&#x2F;ojluni&#x2F;src&#x2F;main&#x2F;java&#x2F;java&#x2F;lang&#x2F;Runtime.java (这里主要参考了android10的源码)\n这两种方式的区别在于，System.load的参数为libpath，直接传入so路径加载。而System.LoadLibrary的参数为libname，需要先查找路径再进行加载。\npublic static void load(String filename) &#123;    Runtime.getRuntime().load0(Reflection.getCallerClass(), filename);&#125;public static void loadLibrary(String libname) &#123;    Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);&#125;\n\nloadLibrary0private synchronized void loadLibrary0(ClassLoader loader, Class&lt;?&gt; callerClass, String libname) &#123;      if (libname.indexOf((int)File.separatorChar) != -1) &#123;          throw new UnsatisfiedLinkError(  &quot;Directory separator should not appear in library name: &quot; + libname);      &#125;      String libraryName = libname;        if (loader != null &amp;&amp; !(loader instanceof BootClassLoader)) &#123;          //loader不为空          String filename = loader.findLibrary(libraryName);          //获取动态库路径          if (filename == null) &#123;                            throw new UnsatisfiedLinkError(loader + &quot; couldn&#x27;t find \\&quot;&quot; +                                             System.mapLibraryName(libraryName) + &quot;\\&quot;&quot;);          &#125;          String error = nativeLoad(filename, loader);          if (error != null) &#123;              throw new UnsatisfiedLinkError(error);          &#125;          return;      &#125;      //loader为空      getLibPaths();             String filename = System.mapLibraryName(libraryName);      String error = nativeLoad(filename, loader, callerClass);      if (error != null) &#123;          throw new UnsatisfiedLinkError(error);      &#125;  &#125;\n\nloadLibrary0会判断ClassLoader是否为空，当ClassLoader为不为空时会通过findLibrary来获取完整路径，当ClassLoader为空时则会通过getLIbPaths来获取。最后通过nativeLoad来加载。\n\nprotected String findLibrary(String libname) &#123;   return null;&#125;\n\nClassLoader中的findLibrary为空，要知道是使用的是哪个ClassLoader可以在程序中打印ClassLoader，发现运行的是PathClassLoader。同时还输出了nativeLibraryDirectories，很明显这就是加载so时查找的路径,它是怎么来的呢，先继续往下看。\n\nnativeLibraryDirectories=[        /data/app/com.example.loadso-T289WyOMZa9KcrBp8H3Fbw==/lib/arm64,         /data/app/com.example.loadso-T289WyOMZa9KcrBp8H3Fbw==/base.apk!/lib/arm64-v8a,         /system/lib64,         /vendor/lib64,         /system/product/lib64]]]\n\nPathClassLoader继承自BaseDexClassLoader。\n//PathCLassLoader.javapublic PathClassLoader(String dexPath, String librarySearchPath, ClassLoader parent) &#123;      super(dexPath, null, librarySearchPath, parent); &#125;//BaseDexClassLoader.javapublic BaseDexClassLoader(String dexPath,              String librarySearchPath, ClassLoader parent, ClassLoader[] sharedLibraryLoaders,              boolean isTrusted) &#123;          super(parent);          // Setup shared libraries before creating the path list. ART relies on the class loader          // hierarchy being finalized before loading dex files.          this.sharedLibraryLoaders = sharedLibraryLoaders == null                  ? null                  : Arrays.copyOf(sharedLibraryLoaders, sharedLibraryLoaders.length);          this.pathList = new DexPathList(this, dexPath, librarySearchPath, null, isTrusted);            if (reporter != null) &#123;              reportClassLoaderChain();          &#125;      &#125;\n\nBaseDexClassLoader使用librarySearchPath初始化了一个DexPathList对象。调用的findLibrary是DexPathList的findLibrary方法。\n//BaseDexlassLoader.javapublic String findLibrary(String name) &#123;          return pathList.findLibrary(name);&#125;//DexPathList.javapublic String findLibrary(String libraryName) &#123;    //获取完整文件名  String fileName = System.mapLibraryName(libraryName);  for (NativeLibraryElement element : nativeLibraryPathElements) &#123;      String path = element.findNativeLibrary(fileName);      if (path != null) &#123;          return path;      &#125;  &#125;  return null;&#125;\n\n同时toString方法也是DexPathList对象的toString方法。也就是说前面输出的是nativeLibraryDirectories和systemNativeLibraryDirectories合并后的路径列表。接下来分析它们分别是什么。\n//baseDexClassLoader.java@Override public String toString() &#123;  return getClass().getName() + &quot;[&quot; + pathList + &quot;]&quot;;&#125;//DexPathList.java@Override public String toString() &#123;  return &quot;DexPathList[&quot; + Arrays.toString(dexElements) +      &quot;,nativeLibraryDirectories=&quot; +      Arrays.toString(getAllNativeLibraryDirectories().toArray()) + &quot;]&quot;;&#125;private List&lt;File&gt; getAllNativeLibraryDirectories() &#123;  List&lt;File&gt; allNativeLibraryDirectories = new ArrayList&lt;&gt;(nativeLibraryDirectories);  allNativeLibraryDirectories.addAll(systemNativeLibraryDirectories);  return allNativeLibraryDirectories;&#125;\n\n在DexPathList的构造方法中，librarySearchPath是通过ClassLoader传入的APP自己的so路径，将它赋值给了nativeLibraryDirectories，接着获取了系统默认的搜索路径java.library.path，将它赋值给systemNativeLibraryDirectories，最后将它们组合起来。到这里就能够解释toString方法的输出了。\n//DexPathList.javaDexPathList(ClassLoader definingContext, String dexPath,            String librarySearchPath, File optimizedDirectory, boolean isTrusted) &#123;    ........................    ........................    this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,                                       suppressedExceptions, definingContext, isTrusted);    this.nativeLibraryDirectories = splitPaths(librarySearchPath, false);    this.systemNativeLibraryDirectories =            splitPaths(System.getProperty(&quot;java.library.path&quot;), true);    //获取系统默认加载路径    this.nativeLibraryPathElements = makePathElements(getAllNativeLibraryDirectories());    //合并    if (suppressedExceptions.size() &gt; 0) &#123;        this.dexElementsSuppressedExceptions =            suppressedExceptions.toArray(new IOException[suppressedExceptions.size()]);    &#125; else &#123;        dexElementsSuppressedExceptions = null;    &#125;&#125;\n\n到这里已经清楚so加载的路径是哪些了，但是还有两个问题不太清楚。\n\nDexPathList构造器中获取了java.library.path属性的值，它的值是怎么来的？\n\nSystem_specialProperties中会读取环境变量LD_LIBRARY_PATH的值，若为空则调用android_get_LD_LIBRARY_PATH，最后将其赋值给java.library.path。\n///libcore/ojluni/src/main/native/System.cstatic jobjectArray System_specialProperties(JNIEnv* env, jclass ignored) &#123;    .......    .......    const char* library_path = getenv(&quot;LD_LIBRARY_PATH&quot;);#if defined(__ANDROID__)    if (library_path == NULL) &#123;        android_get_LD_LIBRARY_PATH(path, sizeof(path));        library_path = path;    &#125;#endif    if (library_path == NULL) &#123;        library_path = &quot;&quot;;    &#125;    char* java_path = malloc(strlen(&quot;java.library.path=&quot;) + strlen(library_path) + 1);    strcpy(java_path, &quot;java.library.path=&quot;);    strcat(java_path, library_path);    jstring java_path_str = (*env)-&gt;NewStringUTF(env, java_path);    free((void*)java_path);    if ((*env)-&gt;ExceptionCheck(env)) &#123;        return NULL;    &#125;    (*env)-&gt;SetObjectArrayElement(env, result, 3, java_path_str);    if ((*env)-&gt;ExceptionCheck(env)) &#123;        return NULL;    &#125;    return result;&#125;\n\nandroid_get_LD_LIBRARY_PATH中的do_android_get_LD_LIBRARY_PATH方法会将系统默认的库路径拼接后写入buffer。\nvoid do_android_get_LD_LIBRARY_PATH(char* buffer, size_t buffer_size) &#123;    const auto&amp; default_ld_paths = g_default_namespace.get_default_library_paths();    size_t required_size = 0;    for (const auto&amp; path : default_ld_paths) &#123;        required_size += path.size() + 1;    &#125;    if (buffer_size &lt; required_size) &#123;        async_safe_fatal(&quot;android_get_LD_LIBRARY_PATH failed, buffer too small: &quot;                         &quot;buffer len %zu, required len %zu&quot;, buffer_size, required_size);    &#125;    char* end = buffer;    for (size_t i = 0; i &lt; default_ld_paths.size(); ++i) &#123;        if (i &gt; 0) *end++ = &#x27;:&#x27;;        end = stpcpy(end, default_ld_paths[i].c_str());    &#125;&#125;\n\n\nlibraryPath是app自身的so路径，它是通过ClassLoader传进来的，它又是怎么来的？\n\npublic ClassLoader getClassLoader() &#123;    synchronized(this) &#123;        //...        final ArrayList &lt; String &gt; libPaths = new ArrayList &lt; &gt;();        //...        libPaths.add(mLibDir);\t\t//...        final String lib = TextUtils.join(File.pathSeparator, libPaths);\t\t//...        mClassLoader = ApplicationLoaders.getDefault().getClassLoader(zip, lib, mBaseClassLoader);\t\t//...    &#125;&#125;public LoadedApk(ActivityThread activityThread, ApplicationInfo aInfo, CompatibilityInfo compatInfo, ClassLoader baseLoader, boolean securityViolation, boolean includeCode, boolean registerPackage) &#123;   //...    mLibDir = aInfo.nativeLibraryDir;   //...&#125;\n\n libraryPath来自 app 的 ApplicationInfo 中的 nativeLibraryDir 变量。根据app启动的流程， app 的 ApplicationInfo 信息，包括 nativeLibraryDir 都可以在 data&#x2F;system&#x2F;packages.xml 中查到。\n参考：\nhttps://www.cnblogs.com/dasusu/p/9810673.html \nhttps://juejin.cn/post/6844903993668272141\n","categories":["Android"],"tags":["linux","android","AOSP"]},{"title":"梆梆加固分析(一)","url":"/2025/04/09/bangbang_protect_1/","content":"java层JAVA层的代码量不多, 在attachBaseContext 方法中调用了load方法，具体是加载了一个名为DexHelper的动态库。\n\n\ndoAttach方法使用反射调用了app的代码。说明在加载DexHelper后就已经完成了DEX的释放。接下来分析DexHelper.so\n\n修复DexHelper.so\nIDA打开后可以很明显的看到文件代码段被加密了。.init_proc会在so被加载时执行并完成文件的解密，所以我们只需要HOOK dlopen将DexHelper给dump下来就能得到解密后的so。（也可以调试让程序执行.init_proc然后dump）。\n//frida -U -f &quot;com.chaoxing.mobile&quot; -l dump.jsfunction hook_dlopen()&#123;    var filename = &quot;libDexHelper.so&quot;;    Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;), &#123;        onEnter: function(args) &#123;            if(args[0] != null)&#123;                console.log(&#x27;dlopen called with filename: &#x27; + Memory.readUtf8String(args[0]));                let filepath = Memory.readUtf8String(args[0])                if(filepath.includes(filename))&#123;                   this.loaded = 1;                &#125;            &#125;        &#125;,        onLeave: function(retval)&#123;            console.log(&quot;return&quot;)            if(this.loaded == 1)&#123;                dump_so(filename);                this.loaded = 0;            &#125;            return retval;      &#125;    &#125;    );&#125;function dump_so(filename)&#123;    var handle = Process.getModuleByName(filename);    console.log(&quot;[dumping...........]&quot;);    var path = &quot;/data/data/com.chaoxing.mobile/&quot; + handle.name + &quot;_&quot; + handle.base + &quot;_&quot; + ptr(handle.size) + &quot;.so&quot;;    var file_handle = new File(path, &quot;wb&quot;);    if(!file_handle) &#123;        console.log(&quot;[dump] failed to open file&quot;);    &#125;        Memory.protect(ptr(handle.base), handle.size, &#x27;rwx&#x27;);        var libbuffer = ptr(handle.base).readByteArray(handle.size);        file_handle.write(libbuffer);        file_handle.close();        console.log(&quot;[dump] finished path is &quot; + path);    &#125;setImmediate(hook_dlopen);\n\n然后修复一下ELF文件，我使用了https://github.com/Chenyangming9/SoFixer#。\n\nJNI_OnLoad文件的函数名很多都被混淆了，可以写个idapython脚本恢复函数名。\nimport idautilsimport idcdef rename_functions():    for func_ea in idautils.Functions():        old_name = idc.get_func_name(func_ea)        if old_name.startswith(&quot;pS&quot;) or old_name.startswith(&quot;p5&quot;) or old_name.startswith(&quot;5&quot;) or old_name.startswith(&quot;S&quot;):            new_name = f&quot;sub_&#123;func_ea:X&#125;&quot;        else:            continue  # 不是混淆函数名，跳过        if idc.set_name(func_ea, new_name, idc.SN_NOWARN):            print(f&quot;[+] Renamed: &#123;old_name&#125; -&gt; &#123;new_name&#125; (0x&#123;func_ea:X&#125;)&quot;)# 运行脚本rename_functions()\n\n初始化部分JNI_OnLoad首先注册了一些Native方法，接着对设备运行的环境，包括android版本，android虚拟机类型等进行了一系列的检测。\ncom/secneo/apkwrapper/H    (Ljava/lang/String;)I  he    (Ljava/lang/String;I)V gha    (I)V sha    (Ljava/lang/String;)Ljava/lang/String; dcom/secneo/apkwrapper/AW    (Landroid/content/Context;Landroid/app/Application;)V hn    ()V pn\n\nsub_31278这个函数是加固的核心函数，包括了对libc的hook , 反调试和检测，以及对dex文件的解密等。\n检测分析sub_430C0的函数对libc.so进行了hook,主要hook了read,open,write,mmap等函数。\nsub_4C908中位于偏移0x52BC4的函数向frida-server发送AUTH\\r\\n，检测REJECT。\n\nsub_4CB6C中实现了对环境的检测。包括对root权限，magisk, su等的检测。\n\n之后pthread_create创建了一个线程，函数sub_52EA0 fork了一个子进程并且通过execl启动Java层的检测，主要检测了&#x2F;proc&#x2F;pid&#x2F;status&#x3D;&#x3D;&gt;TracerPid。\n\nsub_4D638函数实现了对hook框架，CLASSPATH的检测，通过对比libart.so中导出函数的前16字节判断是否被修改。\n\nsub_4E308函数主要负责检测虚拟环境，模拟器等。\n\n\n调试器检测主要通过sub_56C10函数来实现，检测&#x2F;proc&#x2F;pid&#x2F;status目录下的TracerPid是否为pid和State字段是否T (stopped)。\n\nDEX文件解密被加密的数据位于最大的dex中，以dexdata0作为标志。搜索dexdata0可以定位到解密并释放Dex的函数。函数偏移为0x3199C.\n\n\n解密函数位于偏移0x38E04，这里会循环解密dex数据。每次申请了0x20000大小的空间，然后将解密后的数据放在其中。解密函数的三个参数分别是密文，解密数据，密钥。事实上在这里就可以dump获取解密的dex文件了。\n\n接着会调用makeInMemoryDexElements，它的作用是将内存中的 DEX 数据（如一个 ByteBuffer 数组）转换为可被类加载器使用的 DexPathList.Element 数组  。\n\n最后调用DexFileLoader::Load加载Dex。\n\n总结：\n简单地分析了这个加固的样本，主要关注了壳的检测部分以及dex文件的解密部分，第一次分析企业版加固，应该还有很多地方没有分析到，VMP的代码位于libdexjni.so，奈何对vmp的了解不多，只能暂时搁置。\n参考：\nhttps://www.cnblogs.com/2014asm/p/14547218.html 梆梆APP加固产品方案浅析\nhttps://bbs.kanxue.com/thread-280513.htm 脱壳纪事——梆梆企业版（一）\n","categories":["逆向"],"tags":["android","脱壳"]},{"title":"android中so的加载(二)","url":"/2025/04/22/android_load_so2/","content":"上一篇文章主要分析了JAVA层的逻辑，接下来主要分析native层的逻辑，native层的入口是nativeLoad函数\nnativeLoad\nloadLibrary在获取到so的路径后就会调用nativeLoad，nativeLoad返回了JVM_NativeLoad函数。\n\n// /art/openjdkjvm/OpenjdkJvm.ccRuntime_nativeLoad(JNIEnv* env, jclass ignored, jstring javaFilename,     jobject javaLoader, jclass caller)&#123;    return JVM_NativeLoad(env, javaFilename, javaLoader, caller);&#125;\n\nJVM_NativeLoad\n获取javaVM并调用LoadNativeLibrary\n\nJNIEXPORT jstring JVM_NativeLoad(JNIEnv* env,                                 jstring javaFilename,                                 jobject javaLoader,                                 jclass caller) &#123;  ScopedUtfChars filename(env, javaFilename);  if (filename.c_str() == nullptr) &#123;    return nullptr;  &#125;  std::string error_msg;  &#123;    art::JavaVMExt* vm = art::Runtime::Current()-&gt;GetJavaVM();    //获取当前java对象    bool success = vm-&gt;LoadNativeLibrary(env,                                         filename.c_str(),                                         javaLoader,                                         caller,                                         &amp;error_msg);    if (success) &#123;      return nullptr;    &#125;  &#125;  // Don&#x27;t let a pending exception from JNI_OnLoad cause a CheckJNI issue with NewStringUTF.  env-&gt;ExceptionClear();  return env-&gt;NewStringUTF(error_msg.c_str());&#125;\n\nLoadNativeLibrary\n1. 检查so是否已经加载，若已加载则检查alloctor避免重复加载\n\n//http://aospxref.com/android-10.0.0_r47/xref/art/runtime/jni/java_vm_ext.cc?fi=LoadNativeLibrary#LoadNativeLibrary bool JavaVMExt::LoadNativeLibrary(JNIEnv* env,                                    const std::string&amp; path,                                    jobject class_loader,                                    jclass caller_class,                                    std::string* error_msg)    SharedLibrary* library;    Thread* self = Thread::Current();    &#123;      // 检查是否已经加载，若已经加载则获取ShardLibrary      MutexLock mu(self, *Locks::jni_libraries_lock_);      library = libraries_-&gt;Get(path);    &#125;    if (library != nullptr) &#123;  // Use the allocator pointers for class loader equality to avoid unnecessary weak root decode.  if (library-&gt;GetClassLoaderAllocator() != class_loader_allocator) &#123;    // The library will be associated with class_loader. The JNI    // spec says we can&#x27;t load the same library into more than one    // class loader.    //    // This isn&#x27;t very common. So spend some time to get a readable message.    ....................    std::string old_class_loader = call_to_string(library-&gt;GetClassLoader());    std::string new_class_loader = call_to_string(class_loader);    // 只能被一个 ClassLoader 加载    StringAppendF(error_msg, &quot;Shared library \\&quot;%s\\&quot; already opened by &quot;        &quot;ClassLoader %p(%s); can&#x27;t open in ClassLoader %p(%s)&quot;,        path.c_str(),        library-&gt;GetClassLoader(),        old_class_loader.c_str(),        class_loader,        new_class_loader.c_str());    LOG(WARNING) &lt;&lt; *error_msg;    return false;  &#125;  VLOG(jni) &lt;&lt; &quot;[Shared library \\&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\\&quot; already loaded in &quot;            &lt;&lt; &quot; ClassLoader &quot; &lt;&lt; class_loader &lt;&lt; &quot;]&quot;;  if (!library-&gt;CheckOnLoadResult()) &#123;    StringAppendF(error_msg, &quot;JNI_OnLoad failed on a previous attempt &quot;        &quot;to load \\&quot;%s\\&quot;&quot;, path.c_str());    return false;  &#125;  return true;&#125;\n\n\n调用OpenNativeLibrary加载\n\nScopedLocalRef&lt;jstring&gt; library_path(env, GetLibrarySearchPath(env, class_loader));Locks::mutator_lock_-&gt;AssertNotHeld(self);const char* path_str = path.empty() ? nullptr : path.c_str();bool needs_native_bridge = false;char* nativeloader_error_msg = nullptr;void* handle = android::OpenNativeLibrary(    env,    runtime_-&gt;GetTargetSdkVersion(),    path_str,    class_loader,    (caller_location.empty() ? nullptr : caller_location.c_str()),    library_path.get(),    &amp;needs_native_bridge,    &amp;nativeloader_error_msg);\n\n\n当so加载成功后立即调用JNI_OnLoad\n\n........void* sym = library-&gt;FindSymbol(&quot;JNI_OnLoad&quot;, nullptr);if (sym == nullptr) &#123;  VLOG(jni) &lt;&lt; &quot;[No JNI_OnLoad found in \\&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\\&quot;]&quot;;  was_successful = true;&#125; else &#123;  // Call JNI_OnLoad.  We have to override the current class  // loader, which will always be &quot;null&quot; since the stuff at the  // top of the stack is around Runtime.loadLibrary().  (See  // the comments in the JNI FindClass function.)  ScopedLocalRef&lt;jobject&gt; old_class_loader(env, env-&gt;NewLocalRef(self-&gt;GetClassLoaderOverride()));  self-&gt;SetClassLoaderOverride(class_loader);  VLOG(jni) &lt;&lt; &quot;[Calling JNI_OnLoad in \\&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\\&quot;]&quot;;  using JNI_OnLoadFn = int(*)(JavaVM*, void*);  JNI_OnLoadFn jni_on_load = reinterpret_cast&lt;JNI_OnLoadFn&gt;(sym);  int version = (*jni_on_load)(this, nullptr);\n\nOpenNativeLibrary\n支持在不同的平台加载so，android平台下使用android_dlopen_ext或dlopen来加载so。\n\n如果 class_loader 为 nullptr，直接通过 android_dlopen_ext 或 dlopen 加载库。  \n若有 caller_location，会根据其来查找对应的 boot_namespace，然后在特定命名空间内加载库。\n如果 class_loader 非空，会查找并创建一个特定的 NativeLoaderNamespace，然后在该命名空间内加载库。\n// /system/core/libnativeloader/native_loader.cppvoid* OpenNativeLibrary(JNIEnv* env, int32_t target_sdk_version, const char* path,jobject class_loader, const char* caller_location, jstring library_path,bool* needs_native_bridge, char** error_msg) &#123;    #if defined(__ANDROID__)    //检查宏定义是否存在    UNUSED(target_sdk_version);    if (class_loader == nullptr) &#123;        //class_loader是否为空        *needs_native_bridge = false;        if (caller_location != nullptr) &#123;            android_namespace_t* boot_namespace = FindExportedNamespace(caller_location);            if (boot_namespace != nullptr) &#123;                //初始化dlextinfo                const android_dlextinfo dlextinfo = &#123;                .flags = ANDROID_DLEXT_USE_NAMESPACE,                .library_namespace = boot_namespace,            &#125;;                //调用了android_dlopen_ext                void* handle = android_dlopen_ext(path, RTLD_NOW, &amp;dlextinfo);                if (handle == nullptr) &#123;                    *error_msg = strdup(dlerror());                &#125;                return handle;            &#125;        &#125;        //调用了dlopen        void* handle = dlopen(path, RTLD_NOW);        if (handle == nullptr) &#123;            *error_msg = strdup(dlerror());        &#125;        return handle;    &#125;    std::lock_guard&lt;std::mutex&gt; guard(g_namespaces_mutex);    NativeLoaderNamespace* ns;    if ((ns = g_namespaces-&gt;FindNamespaceByClassLoader(env, class_loader)) == nullptr) &#123;        // This is the case where the classloader was not created by ApplicationLoaders        // In this case we create an isolated not-shared namespace for it.        std::string create_error_msg;        if ((ns = g_namespaces-&gt;Create(env, target_sdk_version, class_loader, false /* is_shared */,            nullptr, library_path, nullptr, &amp;create_error_msg)) == nullptr) &#123;            *error_msg = strdup(create_error_msg.c_str());            return nullptr;        &#125;    &#125;    return OpenNativeLibraryInNamespace(ns, path, needs_native_bridge, error_msg);    #else    UNUSED(env, target_sdk_version, class_loader, caller_location);    // Do some best effort to emulate library-path support. It will not    // work for dependencies.    //    // Note: null has a special meaning and must be preserved.    std::string c_library_path;  // Empty string by default.    if (library_path != nullptr &amp;&amp; path != nullptr &amp;&amp; path[0] != &#x27;/&#x27;) &#123;        ScopedUtfChars library_path_utf_chars(env, library_path);        c_library_path = library_path_utf_chars.c_str();    &#125;    std::vector&lt;std::string&gt; library_paths = base::Split(c_library_path, &quot;:&quot;);    for (const std::string&amp; lib_path : library_paths) &#123;        *needs_native_bridge = false;        const char* path_arg;        std::string complete_path;        if (path == nullptr) &#123;            // Preserve null.            path_arg = nullptr;        &#125; else &#123;            complete_path = lib_path;            if (!complete_path.empty()) &#123;                complete_path.append(&quot;/&quot;);            &#125;            complete_path.append(path);            path_arg = complete_path.c_str();        &#125;        void* handle = dlopen(path_arg, RTLD_NOW);        if (handle != nullptr) &#123;            return handle;    &#125;    if (NativeBridgeIsSupported(path_arg)) &#123;      *needs_native_bridge = true;      handle = NativeBridgeLoadLibrary(path_arg, RTLD_NOW);      if (handle != nullptr) &#123;        return handle;      &#125;      *error_msg = strdup(NativeBridgeGetError());    &#125; else &#123;      *error_msg = strdup(dlerror());    &#125;  &#125;  return nullptr;#endif&#125;\n\nandroid_dlopen_ext\n///bionic/libdl/libdl.cpp__attribute__((__weak__))void* android_dlopen_ext(const char* filename, int flag, const android_dlextinfo* extinfo) &#123;    const void* caller_addr = __builtin_return_address(0);    return __loader_android_dlopen_ext(filename, flag, extinfo, caller_addr);&#125;\n\n__builtin_return_address(0) 是 GCC 的内建函数，用于获取当前函数调用栈中的返回地址。例如，当libxxx.so中使用dlopen加载某个so时，caller_addr的地址就位于libxxx.so中。当在Java中使用loadLibrary加载时，call_addr的地址就位于libart.so中。最后android_dlopen_ext调用了__loader_android_dlopen_ext 并且把caller作为参数传进去。\n__loader_android_dlopen_ext\n///bionic/libdl/libdl.cppvoid* __loader_android_dlopen_ext(const char* filename,int flags,const android_dlextinfo* extinfo,const void* caller_addr) &#123;    return dlopen_ext(filename, flags, extinfo, caller_addr);&#125;\n\ndlopen_ext\nstatic void* dlopen_ext(const char* filename,int flags,const android_dlextinfo* extinfo,const void* caller_addr) &#123;    ScopedPthreadMutexLocker locker(&amp;g_dl_mutex);    g_linker_logger.ResetState();    void* result = do_dlopen(filename, flags, extinfo, caller_addr);        if (result == nullptr) &#123;        __bionic_format_dlerror(&quot;dlopen failed&quot;, linker_get_error_buffer());        return nullptr;    &#125;    return result;&#125;\n\ndo_dlopen\n在分析do_dlopen前先了解两个概念，命名空间和soinfo结构体。\n\n命名空间(namespace)\n 简单地说命名空间就是用来把不同模块用的动态库隔开、互不干扰，同时又能有选择地共享公共库的机制 。详细地说明可以参考[https://source.android.com/docs/core/architecture/vndk/linker-namespace?hl=zh-cn](https://source.android.com/docs/core/architecture/vndk/linker-namespace?hl=zh-cn)\n\nsoinfo\nsoinfo是linker加载so所涉及到的核心结构，其定义位于/[bionic](http://aospxref.com/android-10.0.0_r47/xref/bionic/)/[linker](http://aospxref.com/android-10.0.0_r47/xref/bionic/linker/)/[linker_soinfo.h](http://aospxref.com/android-10.0.0_r47/xref/bionic/linker/linker_soinfo.h)， 包含 so 的地址、大小、依赖、符号表、构造函数、namespace、名字等等。  \n\n\n\nfind_containing_library的作用是根据caller_addr的地址遍历已加载的soinfo，获取caller所在的so的soinfo。随后使用get_caller_namespace获取caller的命名空间。这段代码的核心是调用了find_library来实现查找加载，链接so。如果加载成功，使用call_constructors调用init函数。\nvoid* do_dlopen(const char* name, int flags,const android_dlextinfo* extinfo,const void* caller_addr) &#123;    std::string trace_prefix = std::string(&quot;dlopen: &quot;) + (name == nullptr ? &quot;(nullptr)&quot; : name);    ScopedTrace trace(trace_prefix.c_str());    ScopedTrace loading_trace((trace_prefix + &quot; - loading and linking&quot;).c_str());        soinfo* const caller = find_containing_library(caller_addr);        android_namespace_t* ns = get_caller_namespace(caller);    LD_LOG(kLogDlopen,        &quot;dlopen(name=\\&quot;%s\\&quot;, flags=0x%x, extinfo=%s, caller=\\&quot;%s\\&quot;, caller_ns=%s@%p, targetSdkVersion=%i) ...&quot;,        name,        flags,        android_dlextinfo_to_string(extinfo).c_str(),        caller == nullptr ? &quot;(null)&quot; : caller-&gt;get_realpath(),        ns == nullptr ? &quot;(null)&quot; : ns-&gt;get_name(),        ns,        get_application_target_sdk_version());    auto purge_guard = android::base::make_scope_guard([&amp;]() &#123; purge_unused_memory(); &#125;);    auto failure_guard = android::base::make_scope_guard(    [&amp;]() &#123; LD_LOG(kLogDlopen, &quot;... dlopen failed: %s&quot;, linker_get_error_buffer()); &#125;);    if ((flags &amp; ~(RTLD_NOW|RTLD_LAZY|RTLD_LOCAL|RTLD_GLOBAL|RTLD_NODELETE|RTLD_NOLOAD)) != 0) &#123;        DL_ERR(&quot;invalid flags to dlopen: %x&quot;, flags);        return nullptr;    &#125;    if (extinfo != nullptr) &#123;        //检查动态库加载的信息        if ((extinfo-&gt;flags &amp; ~(ANDROID_DLEXT_VALID_FLAG_BITS)) != 0) &#123;            DL_ERR(&quot;invalid extended flags to android_dlopen_ext: 0x%&quot; PRIx64, extinfo-&gt;flags);            return nullptr;        &#125;        if ((extinfo-&gt;flags &amp; ANDROID_DLEXT_USE_LIBRARY_FD) == 0 &amp;&amp;            (extinfo-&gt;flags &amp; ANDROID_DLEXT_USE_LIBRARY_FD_OFFSET) != 0) &#123;            DL_ERR(&quot;invalid extended flag combination (ANDROID_DLEXT_USE_LIBRARY_FD_OFFSET without &quot;                &quot;ANDROID_DLEXT_USE_LIBRARY_FD): 0x%&quot; PRIx64, extinfo-&gt;flags);            return nullptr;        &#125;        if ((extinfo-&gt;flags &amp; ANDROID_DLEXT_USE_NAMESPACE) != 0) &#123;            if (extinfo-&gt;library_namespace == nullptr) &#123;                DL_ERR(&quot;ANDROID_DLEXT_USE_NAMESPACE is set but extinfo-&gt;library_namespace is null&quot;);                return nullptr;            &#125;            ns = extinfo-&gt;library_namespace;        &#125;    &#125;    // Workaround for dlopen(/system/lib/&lt;soname&gt;) when .so is in /apex. http://b/121248172    // The workaround works only when targetSdkVersion &lt; Q.    std::string name_to_apex;    if (translateSystemPathToApexPath(name, &amp;name_to_apex)) &#123;        // APEX 路径处理        const char* new_name = name_to_apex.c_str();        LD_LOG(kLogDlopen, &quot;dlopen considering translation from %s to APEX path %s&quot;,            name,            new_name);        // Some APEXs could be optionally disabled. Only translate the path        // when the old file is absent and the new file exists.        if (!file_exists(new_name)) &#123;            LD_LOG(kLogDlopen, &quot;dlopen %s does not exist, not translating&quot;,                   new_name);        &#125; else &#123;            LD_LOG(kLogDlopen, &quot;dlopen translation accepted: using %s&quot;, new_name);            name = new_name;        &#125;    &#125;    // End Workaround for dlopen(/system/lib/&lt;soname&gt;) when .so is in /apex.    std::string asan_name_holder;    //ASAN路径处理    const char* translated_name = name;    if (g_is_asan &amp;&amp; translated_name != nullptr &amp;&amp; translated_name[0] == &#x27;/&#x27;) &#123;        char original_path[PATH_MAX];        if (realpath(name, original_path) != nullptr) &#123;            asan_name_holder = std::string(kAsanLibDirPrefix) + original_path;            if (file_exists(asan_name_holder.c_str())) &#123;                soinfo* si = nullptr;                if (find_loaded_library_by_realpath(ns, original_path, true, &amp;si)) &#123;                    PRINT(&quot;linker_asan dlopen NOT translating \\&quot;%s\\&quot; -&gt; \\&quot;%s\\&quot;: library already loaded&quot;, name,                          asan_name_holder.c_str());                &#125; else &#123;                    PRINT(&quot;linker_asan dlopen translating \\&quot;%s\\&quot; -&gt; \\&quot;%s\\&quot;&quot;, name, translated_name);                    translated_name = asan_name_holder.c_str();                &#125;            &#125;        &#125;    &#125;    ProtectedDataGuard guard;    //通过find_library加载so，返回目标so的soinfo    soinfo* si = find_library(ns, translated_name, flags, extinfo, caller);    loading_trace.End();    if (si != nullptr) &#123;        void* handle = si-&gt;to_handle();        LD_LOG(kLogDlopen,               &quot;... dlopen calling constructors: realpath=\\&quot;%s\\&quot;, soname=\\&quot;%s\\&quot;, handle=%p&quot;,               si-&gt;get_realpath(), si-&gt;get_soname(), handle);        //调用call_constructores - init函数        si-&gt;call_constructors();        failure_guard.Disable();        LD_LOG(kLogDlopen,               &quot;... dlopen successful: realpath=\\&quot;%s\\&quot;, soname=\\&quot;%s\\&quot;, handle=%p&quot;,               si-&gt;get_realpath(), si-&gt;get_soname(), handle);        return handle;    &#125;    return nullptr;&#125;\n\nvoid soinfo::call_constructors() &#123;    if (constructors_called) &#123;        return;    &#125;        constructors_called = true;    if (!is_main_executable() &amp;&amp; preinit_array_ != nullptr) &#123;        // The GNU dynamic linker silently ignores these, but we warn the developer.        PRINT(&quot;\\&quot;%s\\&quot;: ignoring DT_PREINIT_ARRAY in shared library!&quot;, get_realpath());    &#125;    //递归调用子库的构造函数    get_children().for_each([] (soinfo* si) &#123;        si-&gt;call_constructors();    &#125;);    if (!is_linker()) &#123;        bionic_trace_begin((std::string(&quot;calling constructors: &quot;) + get_realpath()).c_str());    &#125;    // DT_INIT should be called before DT_INIT_ARRAY if both are present.    //调用init    call_function(&quot;DT_INIT&quot;, init_func_, get_realpath());    //调用.init_array    call_array(&quot;DT_INIT_ARRAY&quot;, init_array_, init_array_count_, false, get_realpath());    if (!is_linker()) &#123;        bionic_trace_end();    &#125;&#125;\n\nfind_library\nfind_library会调用find_libraries查找并返回指定库的soinfo，若加载成功则增加引用计数并返回。\n\nstatic soinfo* find_library(android_namespace_t* ns,const char* name, int rtld_flags,const android_dlextinfo* extinfo,soinfo* needed_by) &#123;    soinfo* si = nullptr;    if (name == nullptr) &#123;        //获取so本身的soinfo        si = solist_get_somain();    &#125; else if (!find_libraries(ns,        needed_by,        &amp;name,        1,        &amp;si,        nullptr,        0,        rtld_flags,        extinfo,        false /* add_as_children */,        true /* search_linked_namespaces */)) &#123;        if (si != nullptr) &#123;            soinfo_unload(si);        &#125;        return nullptr;    &#125;    si-&gt;increment_ref_count();    return si;&#125;\n\nfind_libraries\n参数解释\n\nbool find_libraries(android_namespace_t* ns,     //caller的命名空间                    soinfo* start_with,          //caller                    const char* const library_names[],  //SoName                    size_t library_names_count,      // 要加载的库的数量 == 1                    soinfo* soinfos[],           // 存放已加载的soinfo                    std::vector&lt;soinfo*&gt;* ld_preloads,  //预加载的soinfo指针                    size_t ld_preloads_count,    //预加载so数量                    int rtld_flags,              //链接标记                    const android_dlextinfo* extinfo,                         bool add_as_children,       //是否添加为子库                    bool search_linked_namespaces,      //是否在链接的命名空间搜索                    std::vector&lt;android_namespace_t*&gt;* namespaces)\n\n准备工作\n这部分主要是将要加载的so加入到待加载队列load_taskds中。\n\nlist of libraries to link - see step 2.  std::unordered_map&lt;const soinfo*, ElfReader&gt; readers_map;  LoadTaskList load_tasks;  // 将要加载的库加入队列  for (size_t i = 0; i &lt; library_names_count; ++i) &#123;    const char* name = library_names[i];    load_tasks.push_back(LoadTask::create(name, start_with, ns, &amp;readers_map));  &#125;  // If soinfos array is null allocate one on stack.  // The array is needed in case of failure; for example  // when library_names[] = &#123;libone.so, libtwo.so&#125; and libone.so  // is loaded correctly but libtwo.so failed for some reason.  // In this case libone.so should be unloaded on return.  // See also implementation of failure_guard below.  if (soinfos == nullptr) &#123;    size_t soinfos_size = sizeof(soinfo*) * library_names_count;    soinfos = reinterpret_cast&lt;soinfo**&gt;(alloca(soinfos_size));    memset(soinfos, 0, soinfos_size);  &#125;  // list of libraries to link - see step 2.  size_t soinfos_count = 0;  auto scope_guard = android::base::make_scope_guard([&amp;]() &#123;    for (LoadTask* t : load_tasks) &#123;      LoadTask::deleter(t);    &#125;  &#125;);  ZipArchiveCache zip_archive_cache;\n\n将依赖库添加到load_tasks\n// Step 1: expand the list of load_tasks to include// all DT_NEEDED libraries (do not load them just yet)for (size_t i = 0; i &lt; load_tasks.size(); ++i) &#123;  LoadTask* task = load_tasks[i];    //遍历每个任务  soinfo* needed_by = task-&gt;get_needed_by();  // 获取被依赖的库，也就是caller  bool is_dt_needed = needed_by != nullptr &amp;&amp; (needed_by != start_with || add_as_children);    task-&gt;set_extinfo(is_dt_needed ? nullptr : extinfo);  task-&gt;set_dt_needed(is_dt_needed);    LD_LOG(kLogDlopen, &quot;find_libraries(ns=%s): task=%s, is_dt_needed=%d&quot;, ns-&gt;get_name(),         task-&gt;get_name(), is_dt_needed);  // Note: start from the namespace that is stored in the LoadTask. This namespace  // is different from the current namespace when the LoadTask is for a transitive  // dependency and the lib that created the LoadTask is not found in the  // current namespace but in one of the linked namespace.      // 调用find_library_internal  if (!find_library_internal(const_cast&lt;android_namespace_t*&gt;(task-&gt;get_start_from()),                             task,                             &amp;zip_archive_cache,                             &amp;load_tasks,                             rtld_flags,                             search_linked_namespaces || is_dt_needed)) &#123;    return false;  &#125;      //获取加载后so的soinfo  soinfo* si = task-&gt;get_soinfo();  //添加依赖  if (is_dt_needed) &#123;    needed_by-&gt;add_child(si);  &#125;  // When ld_preloads is not null, the first  // ld_preloads_count libs are in fact ld_preloads.  if (ld_preloads != nullptr &amp;&amp; soinfos_count &lt; ld_preloads_count) &#123;    ld_preloads-&gt;push_back(si);  &#125;  if (soinfos_count &lt; library_names_count) &#123;    soinfos[soinfos_count++] = si;  &#125;&#125;\n\nfind_library_internal\n1. 通过find_loaded_library_by_soname查看so是否已经被加载过\n2. 若没有加载就调用load_library来查找依赖库\n3. 灰名单处理(某种兼容性的机制)，若is_greylist_enabled启用则会在全局命名空间中查找\n4. 在链接的其他命名空间查找\n\nstatic bool find_library_internal(android_namespace_t* ns,                                   LoadTask* task,                                   ZipArchiveCache* zip_archive_cache,                                   LoadTaskList* load_tasks,                                   int rtld_flags,                                   bool search_linked_namespaces) &#123;    soinfo* candidate;    //若已加载，直接返回    if (find_loaded_library_by_soname(ns, task-&gt;get_name(), search_linked_namespaces, &amp;candidate)) &#123;        LD_LOG(kLogDlopen,               &quot;find_library_internal(ns=%s, task=%s): Already loaded (by soname): %s&quot;,               ns-&gt;get_name(), task-&gt;get_name(), candidate-&gt;get_realpath());        task-&gt;set_soinfo(candidate);        return true;    &#125;    // Library might still be loaded, the accurate detection    // of this fact is done by load_library.    TRACE(&quot;[ \\&quot;%s\\&quot; find_loaded_library_by_soname failed (*candidate=%s@%p). Trying harder... ]&quot;,          task-&gt;get_name(), candidate == nullptr ? &quot;n/a&quot; : candidate-&gt;get_realpath(), candidate);    //加载so    if (load_library(ns, task, zip_archive_cache, load_tasks, rtld_flags, search_linked_namespaces)) &#123;        return true;    &#125;    // TODO(dimitry): workaround for http://b/26394120 (the grey-list)    if (ns-&gt;is_greylist_enabled() &amp;&amp; is_greylisted(ns, task-&gt;get_name(), task-&gt;get_needed_by())) &#123;        // For the libs in the greylist, switch to the default namespace and then        // try the load again from there. The library could be loaded from the        // default namespace or from another namespace (e.g. runtime) that is linked        // from the default namespace.        LD_LOG(kLogDlopen,               &quot;find_library_internal(ns=%s, task=%s): Greylisted library - trying namespace %s&quot;,               ns-&gt;get_name(), task-&gt;get_name(), g_default_namespace.get_name());        ns = &amp;g_default_namespace;        if (load_library(ns, task, zip_archive_cache, load_tasks, rtld_flags,                         search_linked_namespaces)) &#123;            return true;        &#125;    &#125;    // END OF WORKAROUND    if (search_linked_namespaces) &#123;        // if a library was not found - look into linked namespaces        // preserve current dlerror in the case it fails.        DlErrorRestorer dlerror_restorer;        LD_LOG(kLogDlopen, &quot;find_library_internal(ns=%s, task=%s): Trying %zu linked namespaces&quot;,               ns-&gt;get_name(), task-&gt;get_name(), ns-&gt;linked_namespaces().size());        for (auto&amp; linked_namespace : ns-&gt;linked_namespaces()) &#123;            if (find_library_in_linked_namespace(linked_namespace, task)) &#123;                if (task-&gt;get_soinfo() == nullptr) &#123;                    // try to load the library - once namespace boundary is crossed                    // we need to load a library within separate load_group                    // to avoid using symbols from foreign namespace while.                    //                    // However, actual linking is deferred until when the global group                    // is fully identified and is applied to all namespaces.                    // Otherwise, the libs in the linked namespace won&#x27;t get symbols from                    // the global group.                    //                    if (load_library(linked_namespace.linked_namespace(), task, zip_archive_cache, load_tasks, rtld_flags, false)) &#123;                        LD_LOG(                            kLogDlopen, &quot;find_library_internal(ns=%s, task=%s): Found in linked namespace %s&quot;,                            ns-&gt;get_name(), task-&gt;get_name(), linked_namespace.linked_namespace()-&gt;get_name());                        return true;                    &#125;                &#125; else &#123;                    // lib is already loaded                    return true;                &#125;            &#125;        &#125;    &#125;    return false;&#125;\n\nload_library\n通过extinfo中的标志来判断是否需要fd来加载该库，这个标志在OpenNativeLibrary中被定义为了ANDROID_DLEXT_USE_NAMESPACE。那么这里就不会进入这条分支，而是直接通过open_library打开文件获取文件描述符。最后调用重载的load_library方法。\n\nstatic bool load_library(android_namespace_t* ns,                         LoadTask* task,                         ZipArchiveCache* zip_archive_cache,                         LoadTaskList* load_tasks,                         int rtld_flags,                         bool search_linked_namespaces) &#123;    const char* name = task-&gt;get_name();    soinfo* needed_by = task-&gt;get_needed_by();    const android_dlextinfo* extinfo = task-&gt;get_extinfo();    off64_t file_offset;    std::string realpath;        if (extinfo != nullptr &amp;&amp; (extinfo-&gt;flags &amp; ANDROID_DLEXT_USE_LIBRARY_FD) != 0) &#123;        file_offset = 0;        if ((extinfo-&gt;flags &amp; ANDROID_DLEXT_USE_LIBRARY_FD_OFFSET) != 0) &#123;            file_offset = extinfo-&gt;library_fd_offset;        &#125;        if (!realpath_fd(extinfo-&gt;library_fd, &amp;realpath)) &#123;            if (!is_first_stage_init()) &#123;                PRINT(                    &quot;warning: unable to get realpath for the library \\&quot;%s\\&quot; by extinfo-&gt;library_fd. &quot;                    &quot;Will use given name.&quot;,                    name);            &#125;            realpath = name;        &#125;        task-&gt;set_fd(extinfo-&gt;library_fd, false);        task-&gt;set_file_offset(file_offset);        return load_library(ns, task, load_tasks, rtld_flags, realpath, search_linked_namespaces);    &#125;    // Open the file.    //打开文件并且获取文件描述符    int fd = open_library(ns, zip_archive_cache, name, needed_by, &amp;file_offset, &amp;realpath);    if (fd == -1) &#123;        DL_ERR(&quot;library \\&quot;%s\\&quot; not found&quot;, name);        return false;    &#125;    //设置fd    task-&gt;set_fd(fd, true);    task-&gt;set_file_offset(file_offset);    return load_library(ns, task, load_tasks, rtld_flags, realpath, search_linked_namespaces);&#125;\n\nload_library(重载)\n前半部分主要是合法性检测，调用了task->read(realpath.c_str(), file_stat.st_size)来解析ELF文件，之后遍历dynamic解析符号，最后解析依赖库并且将他们也添加到LoadTasks中。\n\nstatic bool load_library(android_namespace_t* ns,                         LoadTask* task,                         LoadTaskList* load_tasks,                         int rtld_flags,                         const std::string&amp; realpath,                         bool search_linked_namespaces) &#123;    off64_t file_offset = task-&gt;get_file_offset();    const char* name = task-&gt;get_name();    const android_dlextinfo* extinfo = task-&gt;get_extinfo();    LD_LOG(kLogDlopen, &quot;load_library(ns=%s, task=%s, flags=0x%x, realpath=%s)&quot;,           ns-&gt;get_name(), name, rtld_flags, realpath.c_str());     //检查file_offset是否对齐    if ((file_offset % PAGE_SIZE) != 0) &#123;        DL_ERR(&quot;file offset for the library \\&quot;%s\\&quot; is not page-aligned: %&quot; PRId64, name, file_offset);        return false;    &#125;        if (file_offset &lt; 0) &#123;        DL_ERR(&quot;file offset for the library \\&quot;%s\\&quot; is negative: %&quot; PRId64, name, file_offset);        return false;    &#125;    struct stat file_stat;    if (TEMP_FAILURE_RETRY(fstat(task-&gt;get_fd(), &amp;file_stat)) != 0) &#123;        DL_ERR(&quot;unable to stat file for the library \\&quot;%s\\&quot;: %s&quot;, name, strerror(errno));        return false;    &#125;    if (file_offset &gt;= file_stat.st_size) &#123;        DL_ERR(&quot;file offset for the library \\&quot;%s\\&quot; &gt;= file size: %&quot; PRId64 &quot; &gt;= %&quot; PRId64,               name, file_offset, file_stat.st_size);        return false;    &#125;    if (extinfo == nullptr || (extinfo-&gt;flags &amp; ANDROID_DLEXT_FORCE_LOAD) == 0) &#123;        soinfo* si = nullptr;        if (find_loaded_library_by_inode(ns, file_stat, file_offset, search_linked_namespaces, &amp;si)) &#123;            LD_LOG(kLogDlopen,                   &quot;load_library(ns=%s, task=%s): Already loaded under different name/path \\&quot;%s\\&quot; - &quot;                   &quot;will return existing soinfo&quot;,                   ns-&gt;get_name(), name, si-&gt;get_realpath());            task-&gt;set_soinfo(si);            return true;        &#125;    &#125;    if ((rtld_flags &amp; RTLD_NOLOAD) != 0) &#123;        DL_ERR(&quot;library \\&quot;%s\\&quot; wasn&#x27;t loaded and RTLD_NOLOAD prevented it&quot;, name);        return false;    &#125;    struct statfs fs_stat;    if (TEMP_FAILURE_RETRY(fstatfs(task-&gt;get_fd(), &amp;fs_stat)) != 0) &#123;        DL_ERR(&quot;unable to fstatfs file for the library \\&quot;%s\\&quot;: %s&quot;, name, strerror(errno));        return false;    &#125;    if ((fs_stat.f_type != TMPFS_MAGIC) &amp;&amp; (!ns-&gt;is_accessible(realpath))) &#123;        const soinfo* needed_by = task-&gt;is_dt_needed() ? task-&gt;get_needed_by() : nullptr;        if (is_greylisted(ns, name, needed_by)) &#123;            if (needed_by == nullptr || !is_system_library(needed_by-&gt;get_realpath())) &#123;                const soinfo* needed_or_dlopened_by = task-&gt;get_needed_by();                const char* sopath = needed_or_dlopened_by == nullptr ? &quot;(unknown)&quot; :                                                               needed_or_dlopened_by-&gt;get_realpath();                DL_WARN_documented_change(__ANDROID_API_N__,                                          &quot;private-api-enforced-for-api-level-24&quot;,                                          &quot;library \\&quot;%s\\&quot; (\\&quot;%s\\&quot;) needed or dlopened by \\&quot;%s\\&quot; &quot;                                          &quot;is not accessible by namespace \\&quot;%s\\&quot;&quot;,                                          name, realpath.c_str(), sopath, ns-&gt;get_name());                add_dlwarning(sopath, &quot;unauthorized access to&quot;,  name);            &#125;        &#125; else &#123;            const char* needed_or_dlopened_by = task-&gt;get_needed_by() == nullptr ?                                                &quot;(unknown)&quot; :                                                task-&gt;get_needed_by()-&gt;get_realpath();            DL_ERR(&quot;library \\&quot;%s\\&quot; needed or dlopened by \\&quot;%s\\&quot; is not accessible for the namespace \\&quot;%s\\&quot;&quot;,                   name, needed_or_dlopened_by, ns-&gt;get_name());            if (!maybe_accessible_via_namespace_links(ns, name)) &#123;                PRINT(&quot;library \\&quot;%s\\&quot; (\\&quot;%s\\&quot;) needed or dlopened by \\&quot;%s\\&quot; is not accessible for the&quot;                      &quot; namespace: [name=\\&quot;%s\\&quot;, ld_library_paths=\\&quot;%s\\&quot;, default_library_paths=\\&quot;%s\\&quot;,&quot;                      &quot; permitted_paths=\\&quot;%s\\&quot;]&quot;,                      name, realpath.c_str(),                      needed_or_dlopened_by,                      ns-&gt;get_name(),                      android::base::Join(ns-&gt;get_ld_library_paths(), &#x27;:&#x27;).c_str(),                      android::base::Join(ns-&gt;get_default_library_paths(), &#x27;:&#x27;).c_str(),                      android::base::Join(ns-&gt;get_permitted_paths(), &#x27;:&#x27;).c_str());            &#125;            return false;        &#125;    &#125;    //初始化了一个soinfo    soinfo* si = soinfo_alloc(ns, realpath.c_str(), &amp;file_stat, file_offset, rtld_flags);    if (si == nullptr) &#123;        return false;    &#125;    //将soinfo添加到task    task-&gt;set_soinfo(si);    //    if (!task-&gt;read(realpath.c_str(), file_stat.st_size)) &#123;        soinfo_free(si);        task-&gt;set_soinfo(nullptr);        return false;    &#125;    //解析dynamic    const ElfReader&amp; elf_reader = task-&gt;get_elf_reader();    for (const ElfW(Dyn)* d = elf_reader.dynamic(); d-&gt;d_tag != DT_NULL; ++d) &#123;        if (d-&gt;d_tag == DT_RUNPATH) &#123;            //DT_RUNPATH            si-&gt;set_dt_runpath(elf_reader.get_string(d-&gt;d_un.d_val));        &#125;        if (d-&gt;d_tag == DT_SONAME) &#123;            //DT_SONAME            si-&gt;set_soname(elf_reader.get_string(d-&gt;d_un.d_val));        &#125;    &#125;#if !defined(__ANDROID__)    if (si-&gt;get_dt_runpath().empty()) &#123;        si-&gt;set_dt_runpath(&quot;$ORIGIN/../lib64:$ORIGIN/lib64&quot;);    &#125;#endif    //解析依赖库    for_each_dt_needed(task-&gt;get_elf_reader(), [&amp;](const char* name) &#123;        LD_LOG(kLogDlopen, &quot;load_library(ns=%s, task=%s): Adding DT_NEEDED task: %s&quot;,               ns-&gt;get_name(), task-&gt;get_name(), name);        //将依赖库添加到load_tasks        load_tasks-&gt;push_back(LoadTask::create(name, si, ns, task-&gt;get_readers_map()));    &#125;);    return true;&#125;\n\nTask::read\nbool read(const char* realpath, off64_t file_size) &#123;      ElfReader&amp; elf_reader = get_elf_reader();      return elf_reader.Read(realpath, fd_, file_offset_, file_size);    &#125;\n\nElfReader::Read\n函数的功能主要是读取ElF头，验证ELF头，读取程序头，读取节区头，读取DynamicSection\n\nbool ElfReader::Read(const char* name, int fd, off64_t file_offset, off64_t file_size) &#123;  if (did_read_) &#123;    return true;  &#125;  name_ = name;  fd_ = fd;  file_offset_ = file_offset;  file_size_ = file_size;  if (ReadElfHeader() &amp;&amp;      VerifyElfHeader() &amp;&amp;      ReadProgramHeaders() &amp;&amp;      ReadSectionHeaders() &amp;&amp;      ReadDynamicSection()) &#123;    did_read_ = true;  &#125;  return did_read_;&#125;\n\n随机顺序加载库\n使用shuffle将load_list中的tasks打乱，之后设置加载时内存空间中的一些参数，最后调用Task.load将所有的segment映射到内存中。\n\n\n    // Step 2: Load libraries in random order (see b/24047022)    LoadTaskList load_list;    for (auto&amp;&amp; task : load_tasks) &#123;        soinfo* si = task-&gt;get_soinfo();        auto pred = [&amp;](const LoadTask* t) &#123;            return t-&gt;get_soinfo() == si;        &#125;;                //将load_tasks中的未链接的so加入load_list中        if (!si-&gt;is_linked() &amp;&amp;            std::find_if(load_list.begin(), load_list.end(), pred) == load_list.end()) &#123;            load_list.push_back(task);        &#125;    &#125;        bool reserved_address_recursive = false;    if (extinfo) &#123;        reserved_address_recursive = extinfo-&gt;flags &amp; ANDROID_DLEXT_RESERVED_ADDRESS_RECURSIVE;    &#125;//获取extinfo中的reserved_address_recursive标志，决定了是否乱序加载    if (!reserved_address_recursive) &#123;        // Shuffle the load order in the normal case, but not if we are loading all        // the libraries to a reserved address range.        shuffle(&amp;load_list);        //shuffle将load_Tasks打乱    &#125;    // 设置地址空间中各项参数    address_space_params extinfo_params, default_params;    size_t relro_fd_offset = 0;    if (extinfo) &#123;        if (extinfo-&gt;flags &amp; ANDROID_DLEXT_RESERVED_ADDRESS) &#123;            extinfo_params.start_addr = extinfo-&gt;reserved_addr;            extinfo_params.reserved_size = extinfo-&gt;reserved_size;            extinfo_params.must_use_address = true;        &#125; else if (extinfo-&gt;flags &amp; ANDROID_DLEXT_RESERVED_ADDRESS_HINT) &#123;            extinfo_params.start_addr = extinfo-&gt;reserved_addr;            extinfo_params.reserved_size = extinfo-&gt;reserved_size;        &#125;    &#125;    for (auto&amp;&amp; task : load_list) &#123;        address_space_params* address_space =            (reserved_address_recursive || !task-&gt;is_dt_needed()) ? &amp;extinfo_params : &amp;default_params;                //执行加载操作        if (!task-&gt;load(address_space)) &#123;            return false;        &#125;    &#125;\n\n预链接依赖库\n按广度优先预链接所有依赖库并注册TLS\n\n// Step 3: pre-link all DT_NEEDED libraries in breadth first order.for (auto&amp;&amp; task : load_tasks) &#123;    soinfo* si = task-&gt;get_soinfo();    //prelink_image完成预链接的功能    if (!si-&gt;is_linked() &amp;&amp; !si-&gt;prelink_image()) &#123;        return false;    &#125;    register_soinfo_tls(si);&#125;\n\n构建全局库组\n在android平台下每个so被加载都对应了一个命名空间，不同的命名空间是隔离的，而全局组里的库则是全局可见。 \n\n    // Step 4: Construct the global group. Note: DF_1_GLOBAL bit of a library is    // determined at step 3.    // Step 4-1: DF_1_GLOBAL bit is force set for LD_PRELOADed libs because they    // must be added to the global group//把LD_PRELOAD加入global group    if (ld_preloads != nullptr) &#123;        for (auto&amp;&amp; si : *ld_preloads) &#123;            si-&gt;set_dt_flags_1(si-&gt;get_dt_flags_1() | DF_1_GLOBAL);        &#125;    &#125;    // Step 4-2: Gather all DF_1_GLOBAL libs which were newly loaded during this    // run. These will be the new member of the global group//把DF_1_GLOBAL以设置或未完成链接的添加到新全局组    soinfo_list_t new_global_group_members;    for (auto&amp;&amp; task : load_tasks) &#123;        soinfo* si = task-&gt;get_soinfo();        if (!si-&gt;is_linked() &amp;&amp; (si-&gt;get_dt_flags_1() &amp; DF_1_GLOBAL) != 0) &#123;            new_global_group_members.push_back(si);        &#125;    &#125;    // Step 4-3: Add the new global group members to all the linked namespaces//将新全局组添加到所有链接的命名空间    if (namespaces != nullptr) &#123;        for (auto linked_ns : *namespaces) &#123;            for (auto si : new_global_group_members) &#123;                if (si-&gt;get_primary_namespace() != linked_ns) &#123;                    linked_ns-&gt;add_soinfo(si);                    si-&gt;add_secondary_namespace(linked_ns);                &#125;            &#125;        &#125;    &#125;\n\n收集本地组的根节点\nloacal_groups是指一组相互依赖，在同一个命名空间中的so。如果依赖关系跨越了命名空间就得新建一个group单独链接。这段代码作用就是把所有跨命名空间依赖的库收集起来单独链接。\n\n// Step 5: Collect roots of local_groups.// Whenever needed_by-&gt;si link crosses a namespace boundary it forms its own local_group.// Here we collect new roots to link them separately later on. Note that we need to avoid// collecting duplicates. Also the order is important. They need to be linked in the same// BFS order we link individual libraries.std::vector&lt;soinfo*&gt; local_group_roots;if (start_with != nullptr &amp;&amp; add_as_children) &#123;    local_group_roots.push_back(start_with);&#125; else &#123;    CHECK(soinfos_count == 1);    local_group_roots.push_back(soinfos[0]);&#125;for (auto&amp;&amp; task : load_tasks) &#123;    soinfo* si = task-&gt;get_soinfo();    soinfo* needed_by = task-&gt;get_needed_by();    bool is_dt_needed = needed_by != nullptr &amp;&amp; (needed_by != start_with || add_as_children);    android_namespace_t* needed_by_ns =        is_dt_needed ? needed_by-&gt;get_primary_namespace() : ns;    if (!si-&gt;is_linked() &amp;&amp; si-&gt;get_primary_namespace() != needed_by_ns) &#123;        auto it = std::find(local_group_roots.begin(), local_group_roots.end(), si);        LD_LOG(kLogDlopen,               &quot;Crossing namespace boundary (si=%s@%p, si_ns=%s@%p, needed_by=%s@%p, ns=%s@%p, needed_by_ns=%s@%p) adding to local_group_roots: %s&quot;,               si-&gt;get_realpath(),               si,               si-&gt;get_primary_namespace()-&gt;get_name(),               si-&gt;get_primary_namespace(),               needed_by == nullptr ? &quot;(nullptr)&quot; : needed_by-&gt;get_realpath(),               needed_by,               ns-&gt;get_name(),               ns,               needed_by_ns-&gt;get_name(),               needed_by_ns,               it == local_group_roots.end() ? &quot;yes&quot; : &quot;no&quot;);        if (it == local_group_roots.end()) &#123;            local_group_roots.push_back(si);        &#125;    &#125;&#125;\n\n在local_group中链接各个引用组\n遍历local_group中的每个soinfo,若没有链接过且属于当前namespace就调用si->image进行重定位。\n\n// Step 6: Link all local groupsfor (auto root : local_group_roots) &#123;    soinfo_list_t local_group;    android_namespace_t* local_group_ns = root-&gt;get_primary_namespace();    //收集local_space    walk_dependencies_tree(root,                           [&amp;] (soinfo* si) &#123;                               if (local_group_ns-&gt;is_accessible(si)) &#123;                                   local_group.push_back(si);                                   return kWalkContinue;                               &#125; else &#123;                                   return kWalkSkip;                               &#125;                           &#125;);    soinfo_list_t global_group = local_group_ns-&gt;get_global_group();    bool linked = local_group.visit([&amp;](soinfo* si) &#123;        // Even though local group may contain accessible soinfos from other namespaces        // we should avoid linking them (because if they are not linked -&gt; they        // are in the local_group_roots and will be linked later).        //检查条件        if (!si-&gt;is_linked() &amp;&amp; si-&gt;get_primary_namespace() == local_group_ns) &#123;            const android_dlextinfo* link_extinfo = nullptr;            if (si == soinfos[0] || reserved_address_recursive) &#123;                // Only forward extinfo for the first library unless the recursive                // flag is set.                link_extinfo = extinfo;            &#125;            if (!si-&gt;link_image(global_group, local_group, link_extinfo, &amp;relro_fd_offset) ||                !get_cfi_shadow()-&gt;AfterLoad(si, solist_get_head())) &#123;                return false;            &#125;        &#125;        return true;    &#125;);    if (!linked) &#123;        return false;    &#125;&#125;\n\n标记所有已链接的依赖库并增加引用计数\n// Step 7: Mark all load_tasks as linked and increment refcounts// for references between load_groups (at this point it does not matter if// referenced load_groups were loaded by previous dlopen or as part of this// one on step 6)if (start_with != nullptr &amp;&amp; add_as_children) &#123;    start_with-&gt;set_linked();&#125;for (auto&amp;&amp; task : load_tasks) &#123;    soinfo* si = task-&gt;get_soinfo();    si-&gt;set_linked();&#125;for (auto&amp;&amp; task : load_tasks) &#123;    soinfo* si = task-&gt;get_soinfo();    soinfo* needed_by = task-&gt;get_needed_by();    if (needed_by != nullptr &amp;&amp;        needed_by != start_with &amp;&amp;        needed_by-&gt;get_local_group_root() != si-&gt;get_local_group_root()) &#123;        si-&gt;increment_ref_count();    &#125;&#125;return true;\n\n\n\n参考：\nhttps://www.cnblogs.com/dasusu/p/9810673.html \nhttps://oacia.dev/android-load-so/\nhttps://juejin.cn/post/6844903993668272141\n","categories":["Android"],"tags":["android","AOSP"]}]