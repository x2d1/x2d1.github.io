[{"title":"android中so的加载(一)","url":"/2025/04/15/android_load_so1/","content":"loadLibraryJava层使用System.LoadLibrary或System.Load来加载so文件。源码位于&#x2F;libcore&#x2F;ojluni&#x2F;src&#x2F;main&#x2F;java&#x2F;java&#x2F;lang&#x2F;Runtime.java (这里主要参考了android10的源码)\n这两种方式的区别在于，System.load的参数为libpath，直接传入so路径加载。而System.LoadLibrary的参数为libname，需要先查找路径再进行加载。\npublic static void load(String filename) &#123;    Runtime.getRuntime().load0(Reflection.getCallerClass(), filename);&#125;public static void loadLibrary(String libname) &#123;    Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);&#125;\n\nloadLibrary0private synchronized void loadLibrary0(ClassLoader loader, Class&lt;?&gt; callerClass, String libname) &#123;      if (libname.indexOf((int)File.separatorChar) != -1) &#123;          throw new UnsatisfiedLinkError(  &quot;Directory separator should not appear in library name: &quot; + libname);      &#125;      String libraryName = libname;        if (loader != null &amp;&amp; !(loader instanceof BootClassLoader)) &#123;          //loader不为空          String filename = loader.findLibrary(libraryName);          //获取动态库路径          if (filename == null) &#123;                            throw new UnsatisfiedLinkError(loader + &quot; couldn&#x27;t find \\&quot;&quot; +                                             System.mapLibraryName(libraryName) + &quot;\\&quot;&quot;);          &#125;          String error = nativeLoad(filename, loader);          if (error != null) &#123;              throw new UnsatisfiedLinkError(error);          &#125;          return;      &#125;      //loader为空      getLibPaths();             String filename = System.mapLibraryName(libraryName);      String error = nativeLoad(filename, loader, callerClass);      if (error != null) &#123;          throw new UnsatisfiedLinkError(error);      &#125;  &#125;\n\nloadLibrary0会判断ClassLoader是否为空，当ClassLoader为不为空时会通过findLibrary来获取完整路径，当ClassLoader为空时则会通过getLIbPaths来获取。最后通过nativeLoad来加载。\n\nprotected String findLibrary(String libname) &#123;   return null;&#125;\n\nClassLoader中的findLibrary为空，要知道是使用的是哪个ClassLoader可以在程序中打印ClassLoader，发现运行的是PathClassLoader。同时还输出了nativeLibraryDirectories，很明显这就是加载so时查找的路径,它是怎么来的呢，先继续往下看。\n\nnativeLibraryDirectories=[        /data/app/com.example.loadso-T289WyOMZa9KcrBp8H3Fbw==/lib/arm64,         /data/app/com.example.loadso-T289WyOMZa9KcrBp8H3Fbw==/base.apk!/lib/arm64-v8a,         /system/lib64,         /vendor/lib64,         /system/product/lib64]]]\n\nPathClassLoader继承自BaseDexClassLoader。\n//PathCLassLoader.javapublic PathClassLoader(String dexPath, String librarySearchPath, ClassLoader parent) &#123;      super(dexPath, null, librarySearchPath, parent); &#125;//BaseDexClassLoader.javapublic BaseDexClassLoader(String dexPath,              String librarySearchPath, ClassLoader parent, ClassLoader[] sharedLibraryLoaders,              boolean isTrusted) &#123;          super(parent);          // Setup shared libraries before creating the path list. ART relies on the class loader          // hierarchy being finalized before loading dex files.          this.sharedLibraryLoaders = sharedLibraryLoaders == null                  ? null                  : Arrays.copyOf(sharedLibraryLoaders, sharedLibraryLoaders.length);          this.pathList = new DexPathList(this, dexPath, librarySearchPath, null, isTrusted);            if (reporter != null) &#123;              reportClassLoaderChain();          &#125;      &#125;\n\nBaseDexClassLoader使用librarySearchPath初始化了一个DexPathList对象。调用的findLibrary是DexPathList的findLibrary方法。\n//BaseDexlassLoader.javapublic String findLibrary(String name) &#123;          return pathList.findLibrary(name);&#125;//DexPathList.javapublic String findLibrary(String libraryName) &#123;    //获取完整文件名  String fileName = System.mapLibraryName(libraryName);  for (NativeLibraryElement element : nativeLibraryPathElements) &#123;      String path = element.findNativeLibrary(fileName);      if (path != null) &#123;          return path;      &#125;  &#125;  return null;&#125;\n\n同时toString方法也是DexPathList对象的toString方法。也就是说前面输出的是nativeLibraryDirectories和systemNativeLibraryDirectories合并后的路径列表。接下来分析它们分别是什么。\n//baseDexClassLoader.java@Override public String toString() &#123;  return getClass().getName() + &quot;[&quot; + pathList + &quot;]&quot;;&#125;//DexPathList.java@Override public String toString() &#123;  return &quot;DexPathList[&quot; + Arrays.toString(dexElements) +      &quot;,nativeLibraryDirectories=&quot; +      Arrays.toString(getAllNativeLibraryDirectories().toArray()) + &quot;]&quot;;&#125;private List&lt;File&gt; getAllNativeLibraryDirectories() &#123;  List&lt;File&gt; allNativeLibraryDirectories = new ArrayList&lt;&gt;(nativeLibraryDirectories);  allNativeLibraryDirectories.addAll(systemNativeLibraryDirectories);  return allNativeLibraryDirectories;&#125;\n\n在DexPathList的构造方法中，librarySearchPath是通过ClassLoader传入的APP自己的so路径，将它赋值给了nativeLibraryDirectories，接着获取了系统默认的搜索路径java.library.path，将它赋值给systemNativeLibraryDirectories，最后将它们组合起来。到这里就能够解释toString方法的输出了。\n//DexPathList.javaDexPathList(ClassLoader definingContext, String dexPath,            String librarySearchPath, File optimizedDirectory, boolean isTrusted) &#123;    ........................    ........................    this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,                                       suppressedExceptions, definingContext, isTrusted);    this.nativeLibraryDirectories = splitPaths(librarySearchPath, false);    this.systemNativeLibraryDirectories =            splitPaths(System.getProperty(&quot;java.library.path&quot;), true);    //获取系统默认加载路径    this.nativeLibraryPathElements = makePathElements(getAllNativeLibraryDirectories());    //合并    if (suppressedExceptions.size() &gt; 0) &#123;        this.dexElementsSuppressedExceptions =            suppressedExceptions.toArray(new IOException[suppressedExceptions.size()]);    &#125; else &#123;        dexElementsSuppressedExceptions = null;    &#125;&#125;\n\n到这里已经清楚so加载的路径是哪些了，但是还有两个问题不太清楚。\n\nDexPathList构造器中获取了java.library.path属性的值，它的值是怎么来的？\n\nSystem_specialProperties中会读取环境变量LD_LIBRARY_PATH的值，若为空则调用android_get_LD_LIBRARY_PATH，最后将其赋值给java.library.path。\n///libcore/ojluni/src/main/native/System.cstatic jobjectArray System_specialProperties(JNIEnv* env, jclass ignored) &#123;    .......    .......    const char* library_path = getenv(&quot;LD_LIBRARY_PATH&quot;);#if defined(__ANDROID__)    if (library_path == NULL) &#123;        android_get_LD_LIBRARY_PATH(path, sizeof(path));        library_path = path;    &#125;#endif    if (library_path == NULL) &#123;        library_path = &quot;&quot;;    &#125;    char* java_path = malloc(strlen(&quot;java.library.path=&quot;) + strlen(library_path) + 1);    strcpy(java_path, &quot;java.library.path=&quot;);    strcat(java_path, library_path);    jstring java_path_str = (*env)-&gt;NewStringUTF(env, java_path);    free((void*)java_path);    if ((*env)-&gt;ExceptionCheck(env)) &#123;        return NULL;    &#125;    (*env)-&gt;SetObjectArrayElement(env, result, 3, java_path_str);    if ((*env)-&gt;ExceptionCheck(env)) &#123;        return NULL;    &#125;    return result;&#125;\n\nandroid_get_LD_LIBRARY_PATH中的do_android_get_LD_LIBRARY_PATH方法会将系统默认的库路径拼接后写入buffer。\nvoid do_android_get_LD_LIBRARY_PATH(char* buffer, size_t buffer_size) &#123;    const auto&amp; default_ld_paths = g_default_namespace.get_default_library_paths();    size_t required_size = 0;    for (const auto&amp; path : default_ld_paths) &#123;        required_size += path.size() + 1;    &#125;    if (buffer_size &lt; required_size) &#123;        async_safe_fatal(&quot;android_get_LD_LIBRARY_PATH failed, buffer too small: &quot;                         &quot;buffer len %zu, required len %zu&quot;, buffer_size, required_size);    &#125;    char* end = buffer;    for (size_t i = 0; i &lt; default_ld_paths.size(); ++i) &#123;        if (i &gt; 0) *end++ = &#x27;:&#x27;;        end = stpcpy(end, default_ld_paths[i].c_str());    &#125;&#125;\n\n\nlibraryPath是app自身的so路径，它是通过ClassLoader传进来的，它又是怎么来的？\n\npublic ClassLoader getClassLoader() &#123;    synchronized(this) &#123;        //...        final ArrayList &lt; String &gt; libPaths = new ArrayList &lt; &gt;();        //...        libPaths.add(mLibDir);\t\t//...        final String lib = TextUtils.join(File.pathSeparator, libPaths);\t\t//...        mClassLoader = ApplicationLoaders.getDefault().getClassLoader(zip, lib, mBaseClassLoader);\t\t//...    &#125;&#125;public LoadedApk(ActivityThread activityThread, ApplicationInfo aInfo, CompatibilityInfo compatInfo, ClassLoader baseLoader, boolean securityViolation, boolean includeCode, boolean registerPackage) &#123;   //...    mLibDir = aInfo.nativeLibraryDir;   //...&#125;\n\n libraryPath来自 app 的 ApplicationInfo 中的 nativeLibraryDir 变量。根据app启动的流程， app 的 ApplicationInfo 信息，包括 nativeLibraryDir 都可以在 data&#x2F;system&#x2F;packages.xml 中查到。\n参考：\nhttps://www.cnblogs.com/dasusu/p/9810673.html \nhttps://juejin.cn/post/6844903993668272141\n","categories":["Android"],"tags":["linux","android","AOSP"]},{"title":"梆梆加固分析(一)","url":"/2025/04/09/bangbang_protect_1/","content":"java层JAVA层的代码量不多, 在attachBaseContext 方法中调用了load方法，具体是加载了一个名为DexHelper的动态库。\n\n\ndoAttach方法使用反射调用了app的代码。说明在加载DexHelper后就已经完成了DEX的释放。接下来分析DexHelper.so\n\n修复DexHelper.so\nIDA打开后可以很明显的看到文件代码段被加密了。.init_proc会在so被加载时执行并完成文件的解密，所以我们只需要HOOK dlopen将DexHelper给dump下来就能得到解密后的so。（也可以调试让程序执行.init_proc然后dump）。\n//frida -U -f &quot;com.chaoxing.mobile&quot; -l dump.jsfunction hook_dlopen()&#123;    var filename = &quot;libDexHelper.so&quot;;    Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;), &#123;        onEnter: function(args) &#123;            if(args[0] != null)&#123;                console.log(&#x27;dlopen called with filename: &#x27; + Memory.readUtf8String(args[0]));                let filepath = Memory.readUtf8String(args[0])                if(filepath.includes(filename))&#123;                   this.loaded = 1;                &#125;            &#125;        &#125;,        onLeave: function(retval)&#123;            console.log(&quot;return&quot;)            if(this.loaded == 1)&#123;                dump_so(filename);                this.loaded = 0;            &#125;            return retval;      &#125;    &#125;    );&#125;function dump_so(filename)&#123;    var handle = Process.getModuleByName(filename);    console.log(&quot;[dumping...........]&quot;);    var path = &quot;/data/data/com.chaoxing.mobile/&quot; + handle.name + &quot;_&quot; + handle.base + &quot;_&quot; + ptr(handle.size) + &quot;.so&quot;;    var file_handle = new File(path, &quot;wb&quot;);    if(!file_handle) &#123;        console.log(&quot;[dump] failed to open file&quot;);    &#125;        Memory.protect(ptr(handle.base), handle.size, &#x27;rwx&#x27;);        var libbuffer = ptr(handle.base).readByteArray(handle.size);        file_handle.write(libbuffer);        file_handle.close();        console.log(&quot;[dump] finished path is &quot; + path);    &#125;setImmediate(hook_dlopen);\n\n然后修复一下ELF文件，我使用了https://github.com/Chenyangming9/SoFixer#。\n\nJNI_OnLoad文件的函数名很多都被混淆了，可以写个idapython脚本恢复函数名。\nimport idautilsimport idcdef rename_functions():    for func_ea in idautils.Functions():        old_name = idc.get_func_name(func_ea)        if old_name.startswith(&quot;pS&quot;) or old_name.startswith(&quot;p5&quot;) or old_name.startswith(&quot;5&quot;) or old_name.startswith(&quot;S&quot;):            new_name = f&quot;sub_&#123;func_ea:X&#125;&quot;        else:            continue  # 不是混淆函数名，跳过        if idc.set_name(func_ea, new_name, idc.SN_NOWARN):            print(f&quot;[+] Renamed: &#123;old_name&#125; -&gt; &#123;new_name&#125; (0x&#123;func_ea:X&#125;)&quot;)# 运行脚本rename_functions()\n\n初始化部分JNI_OnLoad首先注册了一些Native方法，接着对设备运行的环境，包括android版本，android虚拟机类型等进行了一系列的检测。\ncom/secneo/apkwrapper/H    (Ljava/lang/String;)I  he    (Ljava/lang/String;I)V gha    (I)V sha    (Ljava/lang/String;)Ljava/lang/String; dcom/secneo/apkwrapper/AW    (Landroid/content/Context;Landroid/app/Application;)V hn    ()V pn\n\nsub_31278这个函数是加固的核心函数，包括了对libc的hook , 反调试和检测，以及对dex文件的解密等。\n检测分析sub_430C0的函数对libc.so进行了hook,主要hook了read,open,write,mmap等函数。\nsub_4C908中位于偏移0x52BC4的函数向frida-server发送AUTH\\r\\n，检测REJECT。\n\nsub_4CB6C中实现了对环境的检测。包括对root权限，magisk, su等的检测。\n\n之后pthread_create创建了一个线程，函数sub_52EA0 fork了一个子进程并且通过execl启动Java层的检测，主要检测了&#x2F;proc&#x2F;pid&#x2F;status&#x3D;&#x3D;&gt;TracerPid。\n\nsub_4D638函数实现了对hook框架，CLASSPATH的检测，通过对比libart.so中导出函数的前16字节判断是否被修改。\n\nsub_4E308函数主要负责检测虚拟环境，模拟器等。\n\n\n调试器检测主要通过sub_56C10函数来实现，检测&#x2F;proc&#x2F;pid&#x2F;status目录下的TracerPid是否为pid和State字段是否T (stopped)。\n\nDEX文件解密被加密的数据位于最大的dex中，以dexdata0作为标志。搜索dexdata0可以定位到解密并释放Dex的函数。函数偏移为0x3199C.\n\n\n解密函数位于偏移0x38E04，这里会循环解密dex数据。每次申请了0x20000大小的空间，然后将解密后的数据放在其中。解密函数的三个参数分别是密文，解密数据，密钥。事实上在这里就可以dump获取解密的dex文件了。\n\n接着会调用makeInMemoryDexElements，它的作用是将内存中的 DEX 数据（如一个 ByteBuffer 数组）转换为可被类加载器使用的 DexPathList.Element 数组  。\n\n最后调用DexFileLoader::Load加载Dex。\n\n总结：\n简单地分析了这个加固的样本，主要关注了壳的检测部分以及dex文件的解密部分，第一次分析企业版加固，应该还有很多地方没有分析到，VMP的代码位于libdexjni.so，奈何对vmp的了解不多，只能暂时搁置。\n参考：\nhttps://www.cnblogs.com/2014asm/p/14547218.html 梆梆APP加固产品方案浅析\nhttps://bbs.kanxue.com/thread-280513.htm 脱壳纪事——梆梆企业版（一）\n","categories":["逆向"],"tags":["android","脱壳"]},{"title":"android中so的加载(二)","url":"/2025/04/22/android_load_so2/","content":"上一篇文章主要分析了JAVA层的逻辑，接下来主要分析native层的逻辑，native层的入口是nativeLoad函数\nnativeLoad\nloadLibrary在获取到so的路径后就会调用nativeLoad，nativeLoad返回了JVM_NativeLoad函数。\n\n// /art/openjdkjvm/OpenjdkJvm.ccRuntime_nativeLoad(JNIEnv* env, jclass ignored, jstring javaFilename,     jobject javaLoader, jclass caller)&#123;    return JVM_NativeLoad(env, javaFilename, javaLoader, caller);&#125;\n\nJVM_NativeLoad\n获取javaVM并调用LoadNativeLibrary\n\nJNIEXPORT jstring JVM_NativeLoad(JNIEnv* env,                                 jstring javaFilename,                                 jobject javaLoader,                                 jclass caller) &#123;  ScopedUtfChars filename(env, javaFilename);  if (filename.c_str() == nullptr) &#123;    return nullptr;  &#125;  std::string error_msg;  &#123;    art::JavaVMExt* vm = art::Runtime::Current()-&gt;GetJavaVM();    //获取当前java对象    bool success = vm-&gt;LoadNativeLibrary(env,                                         filename.c_str(),                                         javaLoader,                                         caller,                                         &amp;error_msg);    if (success) &#123;      return nullptr;    &#125;  &#125;  // Don&#x27;t let a pending exception from JNI_OnLoad cause a CheckJNI issue with NewStringUTF.  env-&gt;ExceptionClear();  return env-&gt;NewStringUTF(error_msg.c_str());&#125;\n\nLoadNativeLibrary\n1. 检查so是否已经加载，若已加载则检查alloctor避免重复加载\n\n//http://aospxref.com/android-10.0.0_r47/xref/art/runtime/jni/java_vm_ext.cc?fi=LoadNativeLibrary#LoadNativeLibrary bool JavaVMExt::LoadNativeLibrary(JNIEnv* env,                                    const std::string&amp; path,                                    jobject class_loader,                                    jclass caller_class,                                    std::string* error_msg)    SharedLibrary* library;    Thread* self = Thread::Current();    &#123;      // 检查是否已经加载，若已经加载则获取ShardLibrary      MutexLock mu(self, *Locks::jni_libraries_lock_);      library = libraries_-&gt;Get(path);    &#125;    if (library != nullptr) &#123;  // Use the allocator pointers for class loader equality to avoid unnecessary weak root decode.  if (library-&gt;GetClassLoaderAllocator() != class_loader_allocator) &#123;    // The library will be associated with class_loader. The JNI    // spec says we can&#x27;t load the same library into more than one    // class loader.    //    // This isn&#x27;t very common. So spend some time to get a readable message.    ....................    std::string old_class_loader = call_to_string(library-&gt;GetClassLoader());    std::string new_class_loader = call_to_string(class_loader);    // 只能被一个 ClassLoader 加载    StringAppendF(error_msg, &quot;Shared library \\&quot;%s\\&quot; already opened by &quot;        &quot;ClassLoader %p(%s); can&#x27;t open in ClassLoader %p(%s)&quot;,        path.c_str(),        library-&gt;GetClassLoader(),        old_class_loader.c_str(),        class_loader,        new_class_loader.c_str());    LOG(WARNING) &lt;&lt; *error_msg;    return false;  &#125;  VLOG(jni) &lt;&lt; &quot;[Shared library \\&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\\&quot; already loaded in &quot;            &lt;&lt; &quot; ClassLoader &quot; &lt;&lt; class_loader &lt;&lt; &quot;]&quot;;  if (!library-&gt;CheckOnLoadResult()) &#123;    StringAppendF(error_msg, &quot;JNI_OnLoad failed on a previous attempt &quot;        &quot;to load \\&quot;%s\\&quot;&quot;, path.c_str());    return false;  &#125;  return true;&#125;\n\n\n调用OpenNativeLibrary加载\n\nScopedLocalRef&lt;jstring&gt; library_path(env, GetLibrarySearchPath(env, class_loader));Locks::mutator_lock_-&gt;AssertNotHeld(self);const char* path_str = path.empty() ? nullptr : path.c_str();bool needs_native_bridge = false;char* nativeloader_error_msg = nullptr;void* handle = android::OpenNativeLibrary(    env,    runtime_-&gt;GetTargetSdkVersion(),    path_str,    class_loader,    (caller_location.empty() ? nullptr : caller_location.c_str()),    library_path.get(),    &amp;needs_native_bridge,    &amp;nativeloader_error_msg);\n\n\n当so加载成功后立即调用JNI_OnLoad\n\n........void* sym = library-&gt;FindSymbol(&quot;JNI_OnLoad&quot;, nullptr);if (sym == nullptr) &#123;  VLOG(jni) &lt;&lt; &quot;[No JNI_OnLoad found in \\&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\\&quot;]&quot;;  was_successful = true;&#125; else &#123;  // Call JNI_OnLoad.  We have to override the current class  // loader, which will always be &quot;null&quot; since the stuff at the  // top of the stack is around Runtime.loadLibrary().  (See  // the comments in the JNI FindClass function.)  ScopedLocalRef&lt;jobject&gt; old_class_loader(env, env-&gt;NewLocalRef(self-&gt;GetClassLoaderOverride()));  self-&gt;SetClassLoaderOverride(class_loader);  VLOG(jni) &lt;&lt; &quot;[Calling JNI_OnLoad in \\&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\\&quot;]&quot;;  using JNI_OnLoadFn = int(*)(JavaVM*, void*);  JNI_OnLoadFn jni_on_load = reinterpret_cast&lt;JNI_OnLoadFn&gt;(sym);  int version = (*jni_on_load)(this, nullptr);\n\nOpenNativeLibrary\n支持在不同的平台加载so，android平台下使用android_dlopen_ext或dlopen来加载so。\n\n如果 class_loader 为 nullptr，直接通过 android_dlopen_ext 或 dlopen 加载库。  \n若有 caller_location，会根据其来查找对应的 boot_namespace，然后在特定命名空间内加载库。\n如果 class_loader 非空，会查找并创建一个特定的 NativeLoaderNamespace，然后在该命名空间内加载库。\n// /system/core/libnativeloader/native_loader.cppvoid* OpenNativeLibrary(JNIEnv* env, int32_t target_sdk_version, const char* path,jobject class_loader, const char* caller_location, jstring library_path,bool* needs_native_bridge, char** error_msg) &#123;    #if defined(__ANDROID__)    //检查宏定义是否存在    UNUSED(target_sdk_version);    if (class_loader == nullptr) &#123;        //class_loader是否为空        *needs_native_bridge = false;        if (caller_location != nullptr) &#123;            android_namespace_t* boot_namespace = FindExportedNamespace(caller_location);            if (boot_namespace != nullptr) &#123;                //初始化dlextinfo                const android_dlextinfo dlextinfo = &#123;                .flags = ANDROID_DLEXT_USE_NAMESPACE,                .library_namespace = boot_namespace,            &#125;;                //调用了android_dlopen_ext                void* handle = android_dlopen_ext(path, RTLD_NOW, &amp;dlextinfo);                if (handle == nullptr) &#123;                    *error_msg = strdup(dlerror());                &#125;                return handle;            &#125;        &#125;        //调用了dlopen        void* handle = dlopen(path, RTLD_NOW);        if (handle == nullptr) &#123;            *error_msg = strdup(dlerror());        &#125;        return handle;    &#125;    std::lock_guard&lt;std::mutex&gt; guard(g_namespaces_mutex);    NativeLoaderNamespace* ns;    if ((ns = g_namespaces-&gt;FindNamespaceByClassLoader(env, class_loader)) == nullptr) &#123;        // This is the case where the classloader was not created by ApplicationLoaders        // In this case we create an isolated not-shared namespace for it.        std::string create_error_msg;        if ((ns = g_namespaces-&gt;Create(env, target_sdk_version, class_loader, false /* is_shared */,            nullptr, library_path, nullptr, &amp;create_error_msg)) == nullptr) &#123;            *error_msg = strdup(create_error_msg.c_str());            return nullptr;        &#125;    &#125;    return OpenNativeLibraryInNamespace(ns, path, needs_native_bridge, error_msg);    #else    UNUSED(env, target_sdk_version, class_loader, caller_location);    // Do some best effort to emulate library-path support. It will not    // work for dependencies.    //    // Note: null has a special meaning and must be preserved.    std::string c_library_path;  // Empty string by default.    if (library_path != nullptr &amp;&amp; path != nullptr &amp;&amp; path[0] != &#x27;/&#x27;) &#123;        ScopedUtfChars library_path_utf_chars(env, library_path);        c_library_path = library_path_utf_chars.c_str();    &#125;    std::vector&lt;std::string&gt; library_paths = base::Split(c_library_path, &quot;:&quot;);    for (const std::string&amp; lib_path : library_paths) &#123;        *needs_native_bridge = false;        const char* path_arg;        std::string complete_path;        if (path == nullptr) &#123;            // Preserve null.            path_arg = nullptr;        &#125; else &#123;            complete_path = lib_path;            if (!complete_path.empty()) &#123;                complete_path.append(&quot;/&quot;);            &#125;            complete_path.append(path);            path_arg = complete_path.c_str();        &#125;        void* handle = dlopen(path_arg, RTLD_NOW);        if (handle != nullptr) &#123;            return handle;    &#125;    if (NativeBridgeIsSupported(path_arg)) &#123;      *needs_native_bridge = true;      handle = NativeBridgeLoadLibrary(path_arg, RTLD_NOW);      if (handle != nullptr) &#123;        return handle;      &#125;      *error_msg = strdup(NativeBridgeGetError());    &#125; else &#123;      *error_msg = strdup(dlerror());    &#125;  &#125;  return nullptr;#endif&#125;\n\nandroid_dlopen_ext\n///bionic/libdl/libdl.cpp__attribute__((__weak__))void* android_dlopen_ext(const char* filename, int flag, const android_dlextinfo* extinfo) &#123;    const void* caller_addr = __builtin_return_address(0);    return __loader_android_dlopen_ext(filename, flag, extinfo, caller_addr);&#125;\n\n__builtin_return_address(0) 是 GCC 的内建函数，用于获取当前函数调用栈中的返回地址。例如，当libxxx.so中使用dlopen加载某个so时，caller_addr的地址就位于libxxx.so中。当在Java中使用loadLibrary加载时，call_addr的地址就位于libart.so中。最后android_dlopen_ext调用了__loader_android_dlopen_ext 并且把caller作为参数传进去。\n__loader_android_dlopen_ext\n///bionic/libdl/libdl.cppvoid* __loader_android_dlopen_ext(const char* filename,int flags,const android_dlextinfo* extinfo,const void* caller_addr) &#123;    return dlopen_ext(filename, flags, extinfo, caller_addr);&#125;\n\ndlopen_ext\nstatic void* dlopen_ext(const char* filename,int flags,const android_dlextinfo* extinfo,const void* caller_addr) &#123;    ScopedPthreadMutexLocker locker(&amp;g_dl_mutex);    g_linker_logger.ResetState();    void* result = do_dlopen(filename, flags, extinfo, caller_addr);        if (result == nullptr) &#123;        __bionic_format_dlerror(&quot;dlopen failed&quot;, linker_get_error_buffer());        return nullptr;    &#125;    return result;&#125;\n\ndo_dlopen\n在分析do_dlopen前先了解两个概念，命名空间和soinfo结构体。\n\n命名空间(namespace)\n 简单地说命名空间就是用来把不同模块用的动态库隔开、互不干扰，同时又能有选择地共享公共库的机制 。详细地说明可以参考[https://source.android.com/docs/core/architecture/vndk/linker-namespace?hl=zh-cn](https://source.android.com/docs/core/architecture/vndk/linker-namespace?hl=zh-cn)\n\nsoinfo\nsoinfo是linker加载so所涉及到的核心结构，其定义位于/[bionic](http://aospxref.com/android-10.0.0_r47/xref/bionic/)/[linker](http://aospxref.com/android-10.0.0_r47/xref/bionic/linker/)/[linker_soinfo.h](http://aospxref.com/android-10.0.0_r47/xref/bionic/linker/linker_soinfo.h)， 包含 so 的地址、大小、依赖、符号表、构造函数、namespace、名字等等。  \n\n\n\nfind_containing_library的作用是根据caller_addr的地址遍历已加载的soinfo，获取caller所在的so的soinfo。随后使用get_caller_namespace获取caller的命名空间。这段代码的核心是调用了find_library来实现查找加载，链接so。如果加载成功，使用call_constructors调用init函数。\nvoid* do_dlopen(const char* name, int flags,const android_dlextinfo* extinfo,const void* caller_addr) &#123;    std::string trace_prefix = std::string(&quot;dlopen: &quot;) + (name == nullptr ? &quot;(nullptr)&quot; : name);    ScopedTrace trace(trace_prefix.c_str());    ScopedTrace loading_trace((trace_prefix + &quot; - loading and linking&quot;).c_str());        soinfo* const caller = find_containing_library(caller_addr);        android_namespace_t* ns = get_caller_namespace(caller);    LD_LOG(kLogDlopen,        &quot;dlopen(name=\\&quot;%s\\&quot;, flags=0x%x, extinfo=%s, caller=\\&quot;%s\\&quot;, caller_ns=%s@%p, targetSdkVersion=%i) ...&quot;,        name,        flags,        android_dlextinfo_to_string(extinfo).c_str(),        caller == nullptr ? &quot;(null)&quot; : caller-&gt;get_realpath(),        ns == nullptr ? &quot;(null)&quot; : ns-&gt;get_name(),        ns,        get_application_target_sdk_version());    auto purge_guard = android::base::make_scope_guard([&amp;]() &#123; purge_unused_memory(); &#125;);    auto failure_guard = android::base::make_scope_guard(    [&amp;]() &#123; LD_LOG(kLogDlopen, &quot;... dlopen failed: %s&quot;, linker_get_error_buffer()); &#125;);    if ((flags &amp; ~(RTLD_NOW|RTLD_LAZY|RTLD_LOCAL|RTLD_GLOBAL|RTLD_NODELETE|RTLD_NOLOAD)) != 0) &#123;        DL_ERR(&quot;invalid flags to dlopen: %x&quot;, flags);        return nullptr;    &#125;    if (extinfo != nullptr) &#123;        //检查动态库加载的信息        if ((extinfo-&gt;flags &amp; ~(ANDROID_DLEXT_VALID_FLAG_BITS)) != 0) &#123;            DL_ERR(&quot;invalid extended flags to android_dlopen_ext: 0x%&quot; PRIx64, extinfo-&gt;flags);            return nullptr;        &#125;        if ((extinfo-&gt;flags &amp; ANDROID_DLEXT_USE_LIBRARY_FD) == 0 &amp;&amp;            (extinfo-&gt;flags &amp; ANDROID_DLEXT_USE_LIBRARY_FD_OFFSET) != 0) &#123;            DL_ERR(&quot;invalid extended flag combination (ANDROID_DLEXT_USE_LIBRARY_FD_OFFSET without &quot;                &quot;ANDROID_DLEXT_USE_LIBRARY_FD): 0x%&quot; PRIx64, extinfo-&gt;flags);            return nullptr;        &#125;        if ((extinfo-&gt;flags &amp; ANDROID_DLEXT_USE_NAMESPACE) != 0) &#123;            if (extinfo-&gt;library_namespace == nullptr) &#123;                DL_ERR(&quot;ANDROID_DLEXT_USE_NAMESPACE is set but extinfo-&gt;library_namespace is null&quot;);                return nullptr;            &#125;            ns = extinfo-&gt;library_namespace;        &#125;    &#125;    // Workaround for dlopen(/system/lib/&lt;soname&gt;) when .so is in /apex. http://b/121248172    // The workaround works only when targetSdkVersion &lt; Q.    std::string name_to_apex;    if (translateSystemPathToApexPath(name, &amp;name_to_apex)) &#123;        // APEX 路径处理        const char* new_name = name_to_apex.c_str();        LD_LOG(kLogDlopen, &quot;dlopen considering translation from %s to APEX path %s&quot;,            name,            new_name);        // Some APEXs could be optionally disabled. Only translate the path        // when the old file is absent and the new file exists.        if (!file_exists(new_name)) &#123;            LD_LOG(kLogDlopen, &quot;dlopen %s does not exist, not translating&quot;,                   new_name);        &#125; else &#123;            LD_LOG(kLogDlopen, &quot;dlopen translation accepted: using %s&quot;, new_name);            name = new_name;        &#125;    &#125;    // End Workaround for dlopen(/system/lib/&lt;soname&gt;) when .so is in /apex.    std::string asan_name_holder;    //ASAN路径处理    const char* translated_name = name;    if (g_is_asan &amp;&amp; translated_name != nullptr &amp;&amp; translated_name[0] == &#x27;/&#x27;) &#123;        char original_path[PATH_MAX];        if (realpath(name, original_path) != nullptr) &#123;            asan_name_holder = std::string(kAsanLibDirPrefix) + original_path;            if (file_exists(asan_name_holder.c_str())) &#123;                soinfo* si = nullptr;                if (find_loaded_library_by_realpath(ns, original_path, true, &amp;si)) &#123;                    PRINT(&quot;linker_asan dlopen NOT translating \\&quot;%s\\&quot; -&gt; \\&quot;%s\\&quot;: library already loaded&quot;, name,                          asan_name_holder.c_str());                &#125; else &#123;                    PRINT(&quot;linker_asan dlopen translating \\&quot;%s\\&quot; -&gt; \\&quot;%s\\&quot;&quot;, name, translated_name);                    translated_name = asan_name_holder.c_str();                &#125;            &#125;        &#125;    &#125;    ProtectedDataGuard guard;    //通过find_library加载so，返回目标so的soinfo    soinfo* si = find_library(ns, translated_name, flags, extinfo, caller);    loading_trace.End();    if (si != nullptr) &#123;        void* handle = si-&gt;to_handle();        LD_LOG(kLogDlopen,               &quot;... dlopen calling constructors: realpath=\\&quot;%s\\&quot;, soname=\\&quot;%s\\&quot;, handle=%p&quot;,               si-&gt;get_realpath(), si-&gt;get_soname(), handle);        //调用call_constructores - init函数        si-&gt;call_constructors();        failure_guard.Disable();        LD_LOG(kLogDlopen,               &quot;... dlopen successful: realpath=\\&quot;%s\\&quot;, soname=\\&quot;%s\\&quot;, handle=%p&quot;,               si-&gt;get_realpath(), si-&gt;get_soname(), handle);        return handle;    &#125;    return nullptr;&#125;\n\nvoid soinfo::call_constructors() &#123;    if (constructors_called) &#123;        return;    &#125;        constructors_called = true;    if (!is_main_executable() &amp;&amp; preinit_array_ != nullptr) &#123;        // The GNU dynamic linker silently ignores these, but we warn the developer.        PRINT(&quot;\\&quot;%s\\&quot;: ignoring DT_PREINIT_ARRAY in shared library!&quot;, get_realpath());    &#125;    //递归调用子库的构造函数    get_children().for_each([] (soinfo* si) &#123;        si-&gt;call_constructors();    &#125;);    if (!is_linker()) &#123;        bionic_trace_begin((std::string(&quot;calling constructors: &quot;) + get_realpath()).c_str());    &#125;    // DT_INIT should be called before DT_INIT_ARRAY if both are present.    //调用init    call_function(&quot;DT_INIT&quot;, init_func_, get_realpath());    //调用.init_array    call_array(&quot;DT_INIT_ARRAY&quot;, init_array_, init_array_count_, false, get_realpath());    if (!is_linker()) &#123;        bionic_trace_end();    &#125;&#125;\n\nfind_library\nfind_library会调用find_libraries查找并返回指定库的soinfo，若加载成功则增加引用计数并返回。\n\nstatic soinfo* find_library(android_namespace_t* ns,const char* name, int rtld_flags,const android_dlextinfo* extinfo,soinfo* needed_by) &#123;    soinfo* si = nullptr;    if (name == nullptr) &#123;        //获取so本身的soinfo        si = solist_get_somain();    &#125; else if (!find_libraries(ns,        needed_by,        &amp;name,        1,        &amp;si,        nullptr,        0,        rtld_flags,        extinfo,        false /* add_as_children */,        true /* search_linked_namespaces */)) &#123;        if (si != nullptr) &#123;            soinfo_unload(si);        &#125;        return nullptr;    &#125;    si-&gt;increment_ref_count();    return si;&#125;\n\nfind_libraries\n参数解释\n\nbool find_libraries(android_namespace_t* ns,     //caller的命名空间                    soinfo* start_with,          //caller                    const char* const library_names[],  //SoName                    size_t library_names_count,      // 要加载的库的数量 == 1                    soinfo* soinfos[],           // 存放已加载的soinfo                    std::vector&lt;soinfo*&gt;* ld_preloads,  //预加载的soinfo指针                    size_t ld_preloads_count,    //预加载so数量                    int rtld_flags,              //链接标记                    const android_dlextinfo* extinfo,                         bool add_as_children,       //是否添加为子库                    bool search_linked_namespaces,      //是否在链接的命名空间搜索                    std::vector&lt;android_namespace_t*&gt;* namespaces)\n\n准备工作\n这部分主要是将要加载的so加入到待加载队列load_taskds中。\n\nlist of libraries to link - see step 2.  std::unordered_map&lt;const soinfo*, ElfReader&gt; readers_map;  LoadTaskList load_tasks;  // 将要加载的库加入队列  for (size_t i = 0; i &lt; library_names_count; ++i) &#123;    const char* name = library_names[i];    load_tasks.push_back(LoadTask::create(name, start_with, ns, &amp;readers_map));  &#125;  // If soinfos array is null allocate one on stack.  // The array is needed in case of failure; for example  // when library_names[] = &#123;libone.so, libtwo.so&#125; and libone.so  // is loaded correctly but libtwo.so failed for some reason.  // In this case libone.so should be unloaded on return.  // See also implementation of failure_guard below.  if (soinfos == nullptr) &#123;    size_t soinfos_size = sizeof(soinfo*) * library_names_count;    soinfos = reinterpret_cast&lt;soinfo**&gt;(alloca(soinfos_size));    memset(soinfos, 0, soinfos_size);  &#125;  // list of libraries to link - see step 2.  size_t soinfos_count = 0;  auto scope_guard = android::base::make_scope_guard([&amp;]() &#123;    for (LoadTask* t : load_tasks) &#123;      LoadTask::deleter(t);    &#125;  &#125;);  ZipArchiveCache zip_archive_cache;\n\n将依赖库添加到load_tasks\n// Step 1: expand the list of load_tasks to include// all DT_NEEDED libraries (do not load them just yet)for (size_t i = 0; i &lt; load_tasks.size(); ++i) &#123;  LoadTask* task = load_tasks[i];    //遍历每个任务  soinfo* needed_by = task-&gt;get_needed_by();  // 获取被依赖的库，也就是caller  bool is_dt_needed = needed_by != nullptr &amp;&amp; (needed_by != start_with || add_as_children);    task-&gt;set_extinfo(is_dt_needed ? nullptr : extinfo);  task-&gt;set_dt_needed(is_dt_needed);    LD_LOG(kLogDlopen, &quot;find_libraries(ns=%s): task=%s, is_dt_needed=%d&quot;, ns-&gt;get_name(),         task-&gt;get_name(), is_dt_needed);  // Note: start from the namespace that is stored in the LoadTask. This namespace  // is different from the current namespace when the LoadTask is for a transitive  // dependency and the lib that created the LoadTask is not found in the  // current namespace but in one of the linked namespace.      // 调用find_library_internal  if (!find_library_internal(const_cast&lt;android_namespace_t*&gt;(task-&gt;get_start_from()),                             task,                             &amp;zip_archive_cache,                             &amp;load_tasks,                             rtld_flags,                             search_linked_namespaces || is_dt_needed)) &#123;    return false;  &#125;      //获取加载后so的soinfo  soinfo* si = task-&gt;get_soinfo();  //添加依赖  if (is_dt_needed) &#123;    needed_by-&gt;add_child(si);  &#125;  // When ld_preloads is not null, the first  // ld_preloads_count libs are in fact ld_preloads.  if (ld_preloads != nullptr &amp;&amp; soinfos_count &lt; ld_preloads_count) &#123;    ld_preloads-&gt;push_back(si);  &#125;  if (soinfos_count &lt; library_names_count) &#123;    soinfos[soinfos_count++] = si;  &#125;&#125;\n\nfind_library_internal\n1. 通过find_loaded_library_by_soname查看so是否已经被加载过\n2. 若没有加载就调用load_library来查找依赖库\n3. 灰名单处理(某种兼容性的机制)，若is_greylist_enabled启用则会在全局命名空间中查找\n4. 在链接的其他命名空间查找\n\nstatic bool find_library_internal(android_namespace_t* ns,                                   LoadTask* task,                                   ZipArchiveCache* zip_archive_cache,                                   LoadTaskList* load_tasks,                                   int rtld_flags,                                   bool search_linked_namespaces) &#123;    soinfo* candidate;    //若已加载，直接返回    if (find_loaded_library_by_soname(ns, task-&gt;get_name(), search_linked_namespaces, &amp;candidate)) &#123;        LD_LOG(kLogDlopen,               &quot;find_library_internal(ns=%s, task=%s): Already loaded (by soname): %s&quot;,               ns-&gt;get_name(), task-&gt;get_name(), candidate-&gt;get_realpath());        task-&gt;set_soinfo(candidate);        return true;    &#125;    // Library might still be loaded, the accurate detection    // of this fact is done by load_library.    TRACE(&quot;[ \\&quot;%s\\&quot; find_loaded_library_by_soname failed (*candidate=%s@%p). Trying harder... ]&quot;,          task-&gt;get_name(), candidate == nullptr ? &quot;n/a&quot; : candidate-&gt;get_realpath(), candidate);    //加载so    if (load_library(ns, task, zip_archive_cache, load_tasks, rtld_flags, search_linked_namespaces)) &#123;        return true;    &#125;    // TODO(dimitry): workaround for http://b/26394120 (the grey-list)    if (ns-&gt;is_greylist_enabled() &amp;&amp; is_greylisted(ns, task-&gt;get_name(), task-&gt;get_needed_by())) &#123;        // For the libs in the greylist, switch to the default namespace and then        // try the load again from there. The library could be loaded from the        // default namespace or from another namespace (e.g. runtime) that is linked        // from the default namespace.        LD_LOG(kLogDlopen,               &quot;find_library_internal(ns=%s, task=%s): Greylisted library - trying namespace %s&quot;,               ns-&gt;get_name(), task-&gt;get_name(), g_default_namespace.get_name());        ns = &amp;g_default_namespace;        if (load_library(ns, task, zip_archive_cache, load_tasks, rtld_flags,                         search_linked_namespaces)) &#123;            return true;        &#125;    &#125;    // END OF WORKAROUND    if (search_linked_namespaces) &#123;        // if a library was not found - look into linked namespaces        // preserve current dlerror in the case it fails.        DlErrorRestorer dlerror_restorer;        LD_LOG(kLogDlopen, &quot;find_library_internal(ns=%s, task=%s): Trying %zu linked namespaces&quot;,               ns-&gt;get_name(), task-&gt;get_name(), ns-&gt;linked_namespaces().size());        for (auto&amp; linked_namespace : ns-&gt;linked_namespaces()) &#123;            if (find_library_in_linked_namespace(linked_namespace, task)) &#123;                if (task-&gt;get_soinfo() == nullptr) &#123;                    // try to load the library - once namespace boundary is crossed                    // we need to load a library within separate load_group                    // to avoid using symbols from foreign namespace while.                    //                    // However, actual linking is deferred until when the global group                    // is fully identified and is applied to all namespaces.                    // Otherwise, the libs in the linked namespace won&#x27;t get symbols from                    // the global group.                    //                    if (load_library(linked_namespace.linked_namespace(), task, zip_archive_cache, load_tasks, rtld_flags, false)) &#123;                        LD_LOG(                            kLogDlopen, &quot;find_library_internal(ns=%s, task=%s): Found in linked namespace %s&quot;,                            ns-&gt;get_name(), task-&gt;get_name(), linked_namespace.linked_namespace()-&gt;get_name());                        return true;                    &#125;                &#125; else &#123;                    // lib is already loaded                    return true;                &#125;            &#125;        &#125;    &#125;    return false;&#125;\n\nload_library\n通过extinfo中的标志来判断是否需要fd来加载该库，这个标志在OpenNativeLibrary中被定义为了ANDROID_DLEXT_USE_NAMESPACE。那么这里就不会进入这条分支，而是直接通过open_library打开文件获取文件描述符。最后调用重载的load_library方法。\n\nstatic bool load_library(android_namespace_t* ns,                         LoadTask* task,                         ZipArchiveCache* zip_archive_cache,                         LoadTaskList* load_tasks,                         int rtld_flags,                         bool search_linked_namespaces) &#123;    const char* name = task-&gt;get_name();    soinfo* needed_by = task-&gt;get_needed_by();    const android_dlextinfo* extinfo = task-&gt;get_extinfo();    off64_t file_offset;    std::string realpath;        if (extinfo != nullptr &amp;&amp; (extinfo-&gt;flags &amp; ANDROID_DLEXT_USE_LIBRARY_FD) != 0) &#123;        file_offset = 0;        if ((extinfo-&gt;flags &amp; ANDROID_DLEXT_USE_LIBRARY_FD_OFFSET) != 0) &#123;            file_offset = extinfo-&gt;library_fd_offset;        &#125;        if (!realpath_fd(extinfo-&gt;library_fd, &amp;realpath)) &#123;            if (!is_first_stage_init()) &#123;                PRINT(                    &quot;warning: unable to get realpath for the library \\&quot;%s\\&quot; by extinfo-&gt;library_fd. &quot;                    &quot;Will use given name.&quot;,                    name);            &#125;            realpath = name;        &#125;        task-&gt;set_fd(extinfo-&gt;library_fd, false);        task-&gt;set_file_offset(file_offset);        return load_library(ns, task, load_tasks, rtld_flags, realpath, search_linked_namespaces);    &#125;    // Open the file.    //打开文件并且获取文件描述符    int fd = open_library(ns, zip_archive_cache, name, needed_by, &amp;file_offset, &amp;realpath);    if (fd == -1) &#123;        DL_ERR(&quot;library \\&quot;%s\\&quot; not found&quot;, name);        return false;    &#125;    //设置fd    task-&gt;set_fd(fd, true);    task-&gt;set_file_offset(file_offset);    return load_library(ns, task, load_tasks, rtld_flags, realpath, search_linked_namespaces);&#125;\n\nload_library(重载)\n前半部分主要是合法性检测，调用了task->read(realpath.c_str(), file_stat.st_size)来解析ELF文件，之后遍历dynamic解析符号，最后解析依赖库并且将他们也添加到LoadTasks中。\n\nstatic bool load_library(android_namespace_t* ns,                         LoadTask* task,                         LoadTaskList* load_tasks,                         int rtld_flags,                         const std::string&amp; realpath,                         bool search_linked_namespaces) &#123;    off64_t file_offset = task-&gt;get_file_offset();    const char* name = task-&gt;get_name();    const android_dlextinfo* extinfo = task-&gt;get_extinfo();    LD_LOG(kLogDlopen, &quot;load_library(ns=%s, task=%s, flags=0x%x, realpath=%s)&quot;,           ns-&gt;get_name(), name, rtld_flags, realpath.c_str());     //检查file_offset是否对齐    if ((file_offset % PAGE_SIZE) != 0) &#123;        DL_ERR(&quot;file offset for the library \\&quot;%s\\&quot; is not page-aligned: %&quot; PRId64, name, file_offset);        return false;    &#125;        if (file_offset &lt; 0) &#123;        DL_ERR(&quot;file offset for the library \\&quot;%s\\&quot; is negative: %&quot; PRId64, name, file_offset);        return false;    &#125;    struct stat file_stat;    if (TEMP_FAILURE_RETRY(fstat(task-&gt;get_fd(), &amp;file_stat)) != 0) &#123;        DL_ERR(&quot;unable to stat file for the library \\&quot;%s\\&quot;: %s&quot;, name, strerror(errno));        return false;    &#125;    if (file_offset &gt;= file_stat.st_size) &#123;        DL_ERR(&quot;file offset for the library \\&quot;%s\\&quot; &gt;= file size: %&quot; PRId64 &quot; &gt;= %&quot; PRId64,               name, file_offset, file_stat.st_size);        return false;    &#125;    if (extinfo == nullptr || (extinfo-&gt;flags &amp; ANDROID_DLEXT_FORCE_LOAD) == 0) &#123;        soinfo* si = nullptr;        if (find_loaded_library_by_inode(ns, file_stat, file_offset, search_linked_namespaces, &amp;si)) &#123;            LD_LOG(kLogDlopen,                   &quot;load_library(ns=%s, task=%s): Already loaded under different name/path \\&quot;%s\\&quot; - &quot;                   &quot;will return existing soinfo&quot;,                   ns-&gt;get_name(), name, si-&gt;get_realpath());            task-&gt;set_soinfo(si);            return true;        &#125;    &#125;    if ((rtld_flags &amp; RTLD_NOLOAD) != 0) &#123;        DL_ERR(&quot;library \\&quot;%s\\&quot; wasn&#x27;t loaded and RTLD_NOLOAD prevented it&quot;, name);        return false;    &#125;    struct statfs fs_stat;    if (TEMP_FAILURE_RETRY(fstatfs(task-&gt;get_fd(), &amp;fs_stat)) != 0) &#123;        DL_ERR(&quot;unable to fstatfs file for the library \\&quot;%s\\&quot;: %s&quot;, name, strerror(errno));        return false;    &#125;    if ((fs_stat.f_type != TMPFS_MAGIC) &amp;&amp; (!ns-&gt;is_accessible(realpath))) &#123;        const soinfo* needed_by = task-&gt;is_dt_needed() ? task-&gt;get_needed_by() : nullptr;        if (is_greylisted(ns, name, needed_by)) &#123;            if (needed_by == nullptr || !is_system_library(needed_by-&gt;get_realpath())) &#123;                const soinfo* needed_or_dlopened_by = task-&gt;get_needed_by();                const char* sopath = needed_or_dlopened_by == nullptr ? &quot;(unknown)&quot; :                                                               needed_or_dlopened_by-&gt;get_realpath();                DL_WARN_documented_change(__ANDROID_API_N__,                                          &quot;private-api-enforced-for-api-level-24&quot;,                                          &quot;library \\&quot;%s\\&quot; (\\&quot;%s\\&quot;) needed or dlopened by \\&quot;%s\\&quot; &quot;                                          &quot;is not accessible by namespace \\&quot;%s\\&quot;&quot;,                                          name, realpath.c_str(), sopath, ns-&gt;get_name());                add_dlwarning(sopath, &quot;unauthorized access to&quot;,  name);            &#125;        &#125; else &#123;            const char* needed_or_dlopened_by = task-&gt;get_needed_by() == nullptr ?                                                &quot;(unknown)&quot; :                                                task-&gt;get_needed_by()-&gt;get_realpath();            DL_ERR(&quot;library \\&quot;%s\\&quot; needed or dlopened by \\&quot;%s\\&quot; is not accessible for the namespace \\&quot;%s\\&quot;&quot;,                   name, needed_or_dlopened_by, ns-&gt;get_name());            if (!maybe_accessible_via_namespace_links(ns, name)) &#123;                PRINT(&quot;library \\&quot;%s\\&quot; (\\&quot;%s\\&quot;) needed or dlopened by \\&quot;%s\\&quot; is not accessible for the&quot;                      &quot; namespace: [name=\\&quot;%s\\&quot;, ld_library_paths=\\&quot;%s\\&quot;, default_library_paths=\\&quot;%s\\&quot;,&quot;                      &quot; permitted_paths=\\&quot;%s\\&quot;]&quot;,                      name, realpath.c_str(),                      needed_or_dlopened_by,                      ns-&gt;get_name(),                      android::base::Join(ns-&gt;get_ld_library_paths(), &#x27;:&#x27;).c_str(),                      android::base::Join(ns-&gt;get_default_library_paths(), &#x27;:&#x27;).c_str(),                      android::base::Join(ns-&gt;get_permitted_paths(), &#x27;:&#x27;).c_str());            &#125;            return false;        &#125;    &#125;    //初始化了一个soinfo    soinfo* si = soinfo_alloc(ns, realpath.c_str(), &amp;file_stat, file_offset, rtld_flags);    if (si == nullptr) &#123;        return false;    &#125;    //将soinfo添加到task    task-&gt;set_soinfo(si);    //    if (!task-&gt;read(realpath.c_str(), file_stat.st_size)) &#123;        soinfo_free(si);        task-&gt;set_soinfo(nullptr);        return false;    &#125;    //解析dynamic    const ElfReader&amp; elf_reader = task-&gt;get_elf_reader();    for (const ElfW(Dyn)* d = elf_reader.dynamic(); d-&gt;d_tag != DT_NULL; ++d) &#123;        if (d-&gt;d_tag == DT_RUNPATH) &#123;            //DT_RUNPATH            si-&gt;set_dt_runpath(elf_reader.get_string(d-&gt;d_un.d_val));        &#125;        if (d-&gt;d_tag == DT_SONAME) &#123;            //DT_SONAME            si-&gt;set_soname(elf_reader.get_string(d-&gt;d_un.d_val));        &#125;    &#125;#if !defined(__ANDROID__)    if (si-&gt;get_dt_runpath().empty()) &#123;        si-&gt;set_dt_runpath(&quot;$ORIGIN/../lib64:$ORIGIN/lib64&quot;);    &#125;#endif    //解析依赖库    for_each_dt_needed(task-&gt;get_elf_reader(), [&amp;](const char* name) &#123;        LD_LOG(kLogDlopen, &quot;load_library(ns=%s, task=%s): Adding DT_NEEDED task: %s&quot;,               ns-&gt;get_name(), task-&gt;get_name(), name);        //将依赖库添加到load_tasks        load_tasks-&gt;push_back(LoadTask::create(name, si, ns, task-&gt;get_readers_map()));    &#125;);    return true;&#125;\n\nTask::read\nbool read(const char* realpath, off64_t file_size) &#123;      ElfReader&amp; elf_reader = get_elf_reader();      return elf_reader.Read(realpath, fd_, file_offset_, file_size);    &#125;\n\nElfReader::Read\n函数的功能主要是读取ElF头，验证ELF头，读取程序头，读取节区头，读取DynamicSection\n\nbool ElfReader::Read(const char* name, int fd, off64_t file_offset, off64_t file_size) &#123;  if (did_read_) &#123;    return true;  &#125;  name_ = name;  fd_ = fd;  file_offset_ = file_offset;  file_size_ = file_size;  if (ReadElfHeader() &amp;&amp;      VerifyElfHeader() &amp;&amp;      ReadProgramHeaders() &amp;&amp;      ReadSectionHeaders() &amp;&amp;      ReadDynamicSection()) &#123;    did_read_ = true;  &#125;  return did_read_;&#125;\n\n随机顺序加载库\n使用shuffle将load_list中的tasks打乱，之后设置加载时内存空间中的一些参数，最后调用Task.load将所有的segment映射到内存中。\n\n\n    // Step 2: Load libraries in random order (see b/24047022)    LoadTaskList load_list;    for (auto&amp;&amp; task : load_tasks) &#123;        soinfo* si = task-&gt;get_soinfo();        auto pred = [&amp;](const LoadTask* t) &#123;            return t-&gt;get_soinfo() == si;        &#125;;                //将load_tasks中的未链接的so加入load_list中        if (!si-&gt;is_linked() &amp;&amp;            std::find_if(load_list.begin(), load_list.end(), pred) == load_list.end()) &#123;            load_list.push_back(task);        &#125;    &#125;        bool reserved_address_recursive = false;    if (extinfo) &#123;        reserved_address_recursive = extinfo-&gt;flags &amp; ANDROID_DLEXT_RESERVED_ADDRESS_RECURSIVE;    &#125;//获取extinfo中的reserved_address_recursive标志，决定了是否乱序加载    if (!reserved_address_recursive) &#123;        // Shuffle the load order in the normal case, but not if we are loading all        // the libraries to a reserved address range.        shuffle(&amp;load_list);        //shuffle将load_Tasks打乱    &#125;    // 设置地址空间中各项参数    address_space_params extinfo_params, default_params;    size_t relro_fd_offset = 0;    if (extinfo) &#123;        if (extinfo-&gt;flags &amp; ANDROID_DLEXT_RESERVED_ADDRESS) &#123;            extinfo_params.start_addr = extinfo-&gt;reserved_addr;            extinfo_params.reserved_size = extinfo-&gt;reserved_size;            extinfo_params.must_use_address = true;        &#125; else if (extinfo-&gt;flags &amp; ANDROID_DLEXT_RESERVED_ADDRESS_HINT) &#123;            extinfo_params.start_addr = extinfo-&gt;reserved_addr;            extinfo_params.reserved_size = extinfo-&gt;reserved_size;        &#125;    &#125;    for (auto&amp;&amp; task : load_list) &#123;        address_space_params* address_space =            (reserved_address_recursive || !task-&gt;is_dt_needed()) ? &amp;extinfo_params : &amp;default_params;                //执行加载操作        if (!task-&gt;load(address_space)) &#123;            return false;        &#125;    &#125;\n\n预链接依赖库\n按广度优先预链接所有依赖库并注册TLS\n\n// Step 3: pre-link all DT_NEEDED libraries in breadth first order.for (auto&amp;&amp; task : load_tasks) &#123;    soinfo* si = task-&gt;get_soinfo();    //prelink_image完成预链接的功能    if (!si-&gt;is_linked() &amp;&amp; !si-&gt;prelink_image()) &#123;        return false;    &#125;    register_soinfo_tls(si);&#125;\n\n构建全局库组\n在android平台下每个so被加载都对应了一个命名空间，不同的命名空间是隔离的，而全局组里的库则是全局可见。 \n\n    // Step 4: Construct the global group. Note: DF_1_GLOBAL bit of a library is    // determined at step 3.    // Step 4-1: DF_1_GLOBAL bit is force set for LD_PRELOADed libs because they    // must be added to the global group//把LD_PRELOAD加入global group    if (ld_preloads != nullptr) &#123;        for (auto&amp;&amp; si : *ld_preloads) &#123;            si-&gt;set_dt_flags_1(si-&gt;get_dt_flags_1() | DF_1_GLOBAL);        &#125;    &#125;    // Step 4-2: Gather all DF_1_GLOBAL libs which were newly loaded during this    // run. These will be the new member of the global group//把DF_1_GLOBAL以设置或未完成链接的添加到新全局组    soinfo_list_t new_global_group_members;    for (auto&amp;&amp; task : load_tasks) &#123;        soinfo* si = task-&gt;get_soinfo();        if (!si-&gt;is_linked() &amp;&amp; (si-&gt;get_dt_flags_1() &amp; DF_1_GLOBAL) != 0) &#123;            new_global_group_members.push_back(si);        &#125;    &#125;    // Step 4-3: Add the new global group members to all the linked namespaces//将新全局组添加到所有链接的命名空间    if (namespaces != nullptr) &#123;        for (auto linked_ns : *namespaces) &#123;            for (auto si : new_global_group_members) &#123;                if (si-&gt;get_primary_namespace() != linked_ns) &#123;                    linked_ns-&gt;add_soinfo(si);                    si-&gt;add_secondary_namespace(linked_ns);                &#125;            &#125;        &#125;    &#125;\n\n收集本地组的根节点\nloacal_groups是指一组相互依赖，在同一个命名空间中的so。如果依赖关系跨越了命名空间就得新建一个group单独链接。这段代码作用就是把所有跨命名空间依赖的库收集起来单独链接。\n\n// Step 5: Collect roots of local_groups.// Whenever needed_by-&gt;si link crosses a namespace boundary it forms its own local_group.// Here we collect new roots to link them separately later on. Note that we need to avoid// collecting duplicates. Also the order is important. They need to be linked in the same// BFS order we link individual libraries.std::vector&lt;soinfo*&gt; local_group_roots;if (start_with != nullptr &amp;&amp; add_as_children) &#123;    local_group_roots.push_back(start_with);&#125; else &#123;    CHECK(soinfos_count == 1);    local_group_roots.push_back(soinfos[0]);&#125;for (auto&amp;&amp; task : load_tasks) &#123;    soinfo* si = task-&gt;get_soinfo();    soinfo* needed_by = task-&gt;get_needed_by();    bool is_dt_needed = needed_by != nullptr &amp;&amp; (needed_by != start_with || add_as_children);    android_namespace_t* needed_by_ns =        is_dt_needed ? needed_by-&gt;get_primary_namespace() : ns;    if (!si-&gt;is_linked() &amp;&amp; si-&gt;get_primary_namespace() != needed_by_ns) &#123;        auto it = std::find(local_group_roots.begin(), local_group_roots.end(), si);        LD_LOG(kLogDlopen,               &quot;Crossing namespace boundary (si=%s@%p, si_ns=%s@%p, needed_by=%s@%p, ns=%s@%p, needed_by_ns=%s@%p) adding to local_group_roots: %s&quot;,               si-&gt;get_realpath(),               si,               si-&gt;get_primary_namespace()-&gt;get_name(),               si-&gt;get_primary_namespace(),               needed_by == nullptr ? &quot;(nullptr)&quot; : needed_by-&gt;get_realpath(),               needed_by,               ns-&gt;get_name(),               ns,               needed_by_ns-&gt;get_name(),               needed_by_ns,               it == local_group_roots.end() ? &quot;yes&quot; : &quot;no&quot;);        if (it == local_group_roots.end()) &#123;            local_group_roots.push_back(si);        &#125;    &#125;&#125;\n\n在local_group中链接各个引用组\n遍历local_group中的每个soinfo,若没有链接过且属于当前namespace就调用si->image进行重定位。\n\n// Step 6: Link all local groupsfor (auto root : local_group_roots) &#123;    soinfo_list_t local_group;    android_namespace_t* local_group_ns = root-&gt;get_primary_namespace();    //收集local_space    walk_dependencies_tree(root,                           [&amp;] (soinfo* si) &#123;                               if (local_group_ns-&gt;is_accessible(si)) &#123;                                   local_group.push_back(si);                                   return kWalkContinue;                               &#125; else &#123;                                   return kWalkSkip;                               &#125;                           &#125;);    soinfo_list_t global_group = local_group_ns-&gt;get_global_group();    bool linked = local_group.visit([&amp;](soinfo* si) &#123;        // Even though local group may contain accessible soinfos from other namespaces        // we should avoid linking them (because if they are not linked -&gt; they        // are in the local_group_roots and will be linked later).        //检查条件        if (!si-&gt;is_linked() &amp;&amp; si-&gt;get_primary_namespace() == local_group_ns) &#123;            const android_dlextinfo* link_extinfo = nullptr;            if (si == soinfos[0] || reserved_address_recursive) &#123;                // Only forward extinfo for the first library unless the recursive                // flag is set.                link_extinfo = extinfo;            &#125;            if (!si-&gt;link_image(global_group, local_group, link_extinfo, &amp;relro_fd_offset) ||                !get_cfi_shadow()-&gt;AfterLoad(si, solist_get_head())) &#123;                return false;            &#125;        &#125;        return true;    &#125;);    if (!linked) &#123;        return false;    &#125;&#125;\n\n标记所有已链接的依赖库并增加引用计数\n// Step 7: Mark all load_tasks as linked and increment refcounts// for references between load_groups (at this point it does not matter if// referenced load_groups were loaded by previous dlopen or as part of this// one on step 6)if (start_with != nullptr &amp;&amp; add_as_children) &#123;    start_with-&gt;set_linked();&#125;for (auto&amp;&amp; task : load_tasks) &#123;    soinfo* si = task-&gt;get_soinfo();    si-&gt;set_linked();&#125;for (auto&amp;&amp; task : load_tasks) &#123;    soinfo* si = task-&gt;get_soinfo();    soinfo* needed_by = task-&gt;get_needed_by();    if (needed_by != nullptr &amp;&amp;        needed_by != start_with &amp;&amp;        needed_by-&gt;get_local_group_root() != si-&gt;get_local_group_root()) &#123;        si-&gt;increment_ref_count();    &#125;&#125;return true;\n\n\n\n参考：\nhttps://www.cnblogs.com/dasusu/p/9810673.html \nhttps://oacia.dev/android-load-so/\nhttps://juejin.cn/post/6844903993668272141\n","categories":["Android"],"tags":["android","AOSP"]},{"title":"记一次ilibilib参数逆向","url":"/2025/04/30/b_1/","content":"版本：8.42.0\n抓包\n\n\nPOST /x/passport-login/oauth2/login HTTP/2host: passport.bilibili.comaccept: */*accept-encoding: gzip, deflate, brapp-key: android64bili-http-engine: ignetbuvid: XUE61EAECE03D3FB36487B78EBC1F5F96E3E3content-length: 28352content-type: application/x-www-form-urlencoded; charset=utf-8env: prodfp_local: a0ff491bd997295faf0bcaa8a986c4c9202504222203543d9822a4c0573514c2fp_remote: a0ff491bd997295faf0bcaa8a986c4c9202409121254363df3cb17624b67a9adguestid: 24548810039087session_id: cbfe884euser-agent: Mozilla/5.0 BiliDroid/8.42.0 (bbcallen@gmail.com) os/android model/Pixel mobi_app/android build/8420400 channel/html5_share_source_qqchat innerVer/8420410 osVer/10 network/2x-bili-locale-bin: Cg4KAnpoEgRIYW5zGgJDThIOCgJ6aBIESGFucxoCQ04iDUFzaWEvU2hhbmdoYWkqBiswODowMAx-bili-metadata-ip-region: CNx-bili-net-bin: DVVVFT8gAQx-bili-ticket: eyJhbGciOiJIUzI1NiIsImtpZCI6InMwMyIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3NDU1OTY2MzEsImlhdCI6MTc0NTU2NzUzMSwiYnV2aWQiOiJYVUU2MUVBRUNFMDNEM0ZCMzY0ODdCNzhFQkMxRjVGOTZFM0UzIn0.ZfiA3pbBa4d9hv8se7H_4h1vRFKzSy78FoPLAjhXnnEx-bili-trace-id: 628066b1e949a3c75834272712680b9e:5834272712680b9e:0:0appkey=783bbb7264451d82&amp;bili_local_id=a0ff491bd997295faf0bcaa8a986c4c9202504222203543d9822a4c0573514c2&amp;build=8420400&amp;buvid=XUE61EAECE03D3FB36487B78EBC1F5F96E3E3&amp;c_locale=zh-Hans_CN&amp;channel=html5_share_source_qqchat&amp;device=phone&amp;device_id=a0ff491bd997295faf0bcaa8a986c4c9202409121254363df3cb17624b67a9ad&amp;device_meta=A5C0CE4CB6ACAD0ACE202870A1150F7AE2A6E8BC40B61103C6C4BBEE30DFABB7CB315510C0533F5EFA8B3557C121AB4B08D69ED4C308BC02D7DFD671B3CACC51CDF262EF9E0CB0CC683EBC37A526DD785184DA5E0484ED1F78821D7B0785CADE84D7764C01B6278AA17E42855B31499B87C87D1C2AA9E1D4618FF089A9CD7D35697548D9D71FE47224A66A7D93F581D55B6E6433ABE2816DD137D6A5E1D7BD2A4A82C7ED91AF7B04A3899C37E3941BDFC3705AA2849A770DF346D6D52CD6C809F58AEA86961BD5C29FF1D647CD98774318570B127DB643F0266050F11019C397555AD756015C47A09B30891E094ADF7889F3329CD5E351F46AD158172153B09F52492B542F9F889814857D2071A40700A5D45315FA98CA6542632B4E728D37CB907101A08D734A5B56303821122EB1B720CF4888CF0C45CC2E10F67DDC8310FA8C62418620FB30BE03C3F7297D9FCC06E15BD1F962CE2716A7B5EC8112932099776ABD2D65F4C3A57EB6B2796ADC48CC3ABA1738186DB08DE69484777863A380C4517D6B88ED595015CA361DCCC8CED31A9172C002AE4BC7CE4BFA00BF8724327DB7BF0B9C2ED374CD2D182E049A2D10C4788A04E696B2452F96F3BF73E1B8C8B29BE6095F8D6405D956847EBB043A8C08A90D1A99308A008C8B0CC7883D4269C50A0D9C008B81A3CF273C27AEC64B34A52D1197A00289AB0888EE7C17059821F2926C99300EDB8038C0EBB70E56ECC93FBE31DA325098A9B438ACD963ACE33999F3ECF464D3E1E63AFA4D2FA0C42D62F94B5FC3914F3E1929FC685FC3D0685F400E6CB6774C1234F4401AD7CA9995B35975C989C0DEC9EAEA8921937CF1256DD1B1B41A4AE113FD5D5C0160AA1B60C2DE33C2ACDC6A7D68D366EA5DF0122CA25FF364C9B8D74DF805E72B12FAF2265AB36DEBA8F1F948FFC68DDEC6FD573F9692DE81AA888E7771B27249EC699FD7F0C79CD73F7673D6458B2CC2617A5FBE9F725A8E3E5095D46A0D9AF0096EFEBAEF3162BB3E4016659A6C7D1503F56A5E286D5F76B226CB573F47100D9CC112E03EE4C2744FE816C8A68D9819078F9568FFBC773D76318B991EFA812CF6BB2C1580FFC61772F0E861FE4556591710B4CFD180D0379B6413217AAE45B066C7FCAEEA364D4CEDA14031FCE1186AE2B46DA2BCB363DC998AD7E9304E9EFB59E31CBC301644AD84988993982CD585699B1E2FCB1992982D59DED012871A352B16B293C646D615C2D003010CF5E7BD5445C854D286A6AC46EEFEDBA110A9AA67CD5AAC4EA739B9ED1E60D6456E29F62B02F902964214276AB10AD16818745BE06D4FE14859CFBDBC5FFFFAE49860EA8B99A4BD3D92EFD67F1389645310A626176466490EC15DDFF384820F01BF7D1FD75A1300A5F37993A99D09C4785971DD31D9F68A186DB4983098E006A0146FA6155B2F224EBFFFDFE972FBC4732D14EAA824B40D30EFB174CAB1DC231E1CDA47310B346F9298B1AB0A615188F72A1F76D45C9CE53735092448F01432AAF6CBEA451A75F7D727FCF7BC8469475A079180DE2B2AF36F1F0BF12E497048FEF8FBA71A4310D706A95899097E1416CCB3B49A9D7A1A05A0436850EEA869E3CA1DAAFE03C1BF134A089DE7748416BB24105BD1E66D85C565F3740AABC15941F4BB52683CE9AFDD257358306E4D69DF5E55B353B1E22D44963575EB53DE7423C4F8E6BE264888316990C68FBC115414E3EA8EADE154AC8D8FF0225B2B9235DEA033AF887CDD8F9C968891EF3ADF2EC7F803539207AEFDCA371D9F777F7992E21D1F9CFD2DFB99E4F74955DF1B576017098A538B4151BC2DADDFD2D950333861D26DBB6EFD3B5404C57EE0AF8FA2B17244CB85A99643E0002F4B9C3107CFD7281E57410B466FF168F5BE69976ADEFD5B042D48B4584ECCA7AB560993CE65903753E9CCC6E6D227C86EFEFD1C2555DA08262D7564B1F1BBE8812F7CB3332F07498428A9D4115F8743B2E5DC5BA101595D6D3B8FD00C8CD728CD6EEE6CD621298221359E124996A6F6103AD086F37853C8B6B10BD6B6AB4DF77495D43038947825531488D1AB960A4D68577ED567EE360E710905521BA8902ECDF196D1752D483600BA6948354FE1A8E6976EBC7870ACD6BCDF6A368B0CAFE3EC39B66EC74BCA6F5B28254D78B98395F7ABF95AF5FFD8394D5AC246CFE1094FD7AA87CF52A450B32DFBD77E601C575F24B08DF6CB60A5D92EE409DB313CBEBF4BCBBAAB8C385160E48075C3883B241F058B1825F15A4EB56080FCF4EA3985FF9EE15B9C35DC483882273CDFF7D80F003EDC752EA6973C81D9471D36812D9A0126220F232C29DE98D8AADDBE853A23878DA1F0C3F4A018B59A0E0E9DAD36F6839881A5625C86888478CAE262A331FCC57D8635C17770E6CF851E7AFCABFB8F33C07205019EB9E6788B6785B71627ACBB3FD88CB148C134E269392EBE284F1CCA905407302861A8482013738986D82E5086D5315704B7B772A6F8883AB5868F6BE8C979EA7E4CEAAD05537AD2F63FA5157325050312B6DB36213C656F0D13471D99FC193B4D42D2A08F211072BC1D3CBA446910F038E1434F6CF3091F58E19FA9876FB537608CBB3C7F5E64087B06F8C3696B2DE37F1E4731C93B1C96D294FBE2CE1B8AAAF6380792DD0FEE3FA763E76306D0CE3D7A8F116E8FC7AA549A25CC57AA9E1F450CDAD9B1A9189D3B4D2F88E39AFD73690CD79AE9D011901D70558F305C16C57C1F7AAAB108F6CF57AB3C189D3ECE9A13C0F8891DFC4C059451DDF25A52A2F52927F422BDBACB4968B06B252271D0859140F0CC6759577937CF756985AA69BA277B9E52E553D408821D2996EC92AFE70D03A4B13F282F9BEBBFE0A0CA25E2E4864AEA45420F71A90457F83DB6BD7071703784E88F62F3F61562F416A4B3D5D986A053BD363A7BAAFF66123D6152DB1BB0E9777A30FE9E900C2C59AD8A1941728E81CC46583220FE3CD83683C7DD6E126925A53F7C7153DFE237745E87CD0ECC2BBF6AE9FDD5ACE3D572D00BFB7F664DE13480B8277DB74B73BDF1163333786BEBA4063AD9C072E0D370E0C76FDE89C2AC9BA7927823F081AA08F16B735161762549D54939BD3C2BF38095643201A79BD97C0C4BD44B931A5FFED2BF595AA5485F70D3D6A195057D97D5069BB48B04265441923B63BDBC9100046FE6758D94D4A6CAA8D3F78FF1A00487BA017C8F27A931C70D4B750BAD4443CB69EAD44DC6C90D8DBAB146594C308ADCBD0ADD1A070EA1DD44DF2D6291EBB34C5CF3657970D9A3B1685976E84AAA8D0BDDE0DBB4DF4C17BA47D74C06F92324984058ED3410C2547A176CD06641783680DF2639F8383AF0FCD741A52514CA782E9B5EE70FF0D1C0552ECC925EE9409E64D341EEA1A96F7A7EC99B48CEEEFA921DD87DCDA224C823505819BFF7CBDFC2A4E04488C18E03ADA90F69E8B4DD36A05E55E9EF41EAB836BA41B4CB2D7864EDEBD044DA95ADA3BCBF77FDC71CA88B4A4BF5BC532E001028ACD83237A6B2A8C28728AF1D16C1E560E45EA961A72B418823946F6C69750337EAB91A567E8832BD7F8E83A32AB48DD7B95DAD403AE3715CD2D3ABECE33A4597D2301206D87989EFA7652C4F77F57C45D5D052A57E59DCFAF0535380D56433093A0F3A248B5BD59F01793A9FC72D5DD1DFB56FAA325B34F75B60FB00002D97BC688A492609A238BD7EFCE40975302B5B20CB29AA26B18F37FF8C5F7D1C9EC0EECA3AB73B2476B9D95179F6B0A86521FD36EFEA2F8074E4E253035BBA74E931A1922EB6390A75F5ACA3D4B375B4F2CD55787B93C21467EF441DE30E20932323D5F6953BBAF4FE562C84098FAE946A23E054DB8B0058100D7A52DB5BB18F7F381861B7ADF86E87B6C2431EC315E40492DA8E510F0C04E671B59C89E493FE87E723BC8A953BFFFD502B99ED7B2A465F2B670C3BF4392B5B71004B0C6B5A4D69FB7348AD30128A36BE5A59A9D09831404B3C667302271E8BD11B0090E7AFCB26AE3B8E8441611543B93602953CFA0793129A9E836E80BBAB7A1AB164299A5B73F0344DC9B0A7CB5D1CAEBB80D24C54DCB52265FA0C33C97EF969541DC2CD02191C5472093EF4BF1F436BA9A80EBEA2D6EA9B880C470FA5BEF5823D2F6683FF6CD6DE8BBCB1DA83A3C30A4A02DF40681F2BD7C2A73E0DE5350F6BE866761C041CC8825348F9F2C1BA2F6B79419C684096CB64C34C235534B0ACE6E735F824F6E5BB2C784CF31BB6C10BECF11BA81B76849D355E793DBA1A4E8179D41A216FFE9B36EF57F37889B2EA93244CE9438C9D5B55AE826EA380DBB2D309368C324BF4F8B3ED2888C73E3BF744439EA93F7A0156961627298AEBE6BC8B461B8413C964403B609A57B3D9C347E568EDAC6101F7BD4705D8D412E12F20A6DEF472D2B4C755CF74710F094E867BB94CD6B25B5961FEA31262145778902AF70A6ABAEEC2A611190C2996F5199FAD0954307A0B1CC852A325951B27142012BAEEEDED13C4D0A35FA036CF073479EB1DA8FE8A085D6571242F91AF38ADA712DB76049B510238CEAFFE0DCCC52DE55A6C51FB046BA36F9BB99951E72629CD6038DD0E265A328AF0EDC23DF149AD9D58C6758063D13F83EF370573005FE0F333E66F1A8EBA1E70E724DC2C3A2810631CB3C1F7D285B77C594B83A4829733F0853EE4E77BBCABA35798ACD73D6DBAC1C56D5AE9D1C6CFDB57F76676E183CD1A4BA70C2301C729EB27156B73E27177F2B34EE7867ACDF8CC77959692EDFBC7762F44D17E67C24C7C11676C6252CF4E501908E6043D0856D32C51521A3AA2D0DA8970FA7C5F43F4FD6600A9FD764D65C91916D19D4F9200D769A473C45CF1B8B06CA2CFDBB7FB249B1166FDA3EF7A00D302735EE72EFE95DB43A630970889F0E4074072A351C79591DB41F24CF1CC2DED3483AAED513653E856D16A490F5F9EC9A4E99E9DFF2CB27CA6608B1570D3F28825DA040170D18A7F9D3BFECD9365C361302B5C5AD76F6C5A863689345CAF79F763B9E476CE0CDB61B364C05F8BA8B4A315BDA10861725F4C2492A7B6D7E0394E8807D6AF8D47DA96C5B6188F924AF1871FA35B3563F9EFD63F560AFDEEA4434854E472857277033F3E793C4CF0992E7D46669E1FED81B81ED1D3890A91B8A02EA0396065113498590082436F142D56171A19ED323391B5DE28BD33B2A420D4822FC2A8AB2DADCD636ED485A6DEF197C8781C481CE5CD55B327F3091EA7AB74F8FB0AC7294BF9A500CB74409EBDD69376A38BC6FA3275AE721B6CD16F994236F9DC027D9E670663C856D6AB6C6FFE43E32782338620E14D75C59A07343A014FC4BEC45F5D3772B04D7CDDCF8B873018827413373A267BC5BDCDBA5DCA7D83BBB4E266DE025EFCEE2A22A6840FA6CDAA1178007C4250AD8F80EAABF0933E30E63867342675A2B8E4D74C080877FD52777DD00748117FA9E51F2AF52C2FB262E54E8CE7EC2DED1FD948264FC5A110DFAA7E65E3697412BB327B44766D6182DA27CD97768C5AE5DA149BFA1105B136EAB1955023874F4AC66AB9140E85F8D01BE7438332A44FFFF1BEA448B2A58849CCC1755A77919300317670A2F7DEA66D15AE8335C03D7E7CA84471C18EEC117203BBE93D32A7603EF8AE7AB899DFC06498C21D7BF17B9262EF1F59A9554E6237110EC836802EDC89D1156C420B416C399FF56AD4408974051FC9A69EAFD49B8DFB8D537BC400E5D2CD8D6B6C443E4BF50DBCD4A240C7A1ADB6D368C4DC1F6F5529EF2B2FDAED1CA7F255FF0197D17DCFC747FE43E93388EDCFF2EA76FB87BCFC980F3E16B49F1CDE872BC97AC8CF133883F30777095A350983F2A3225813FD83CB290F4FA29316E2EF83D71C9EE3776304EA123EE35035BBD42059649E7C381BDC6C9D246A92B1A71409A4F1837404182D1FA3B680BB3C4778EA3EED4D71768BEE3825A553F390DB1CE65D0BAF83785C7F55B7A379F97558AE2915A745C18A6311E909BEE5C5247ED9C78DF9CEEE3166862D33149DC698CD8953C8BE7AE727B30231960AF879AF7FAB4AA43DF08676046130B1B2F41FD826A2011861959BAAF978AB079372B9EF3559C1FDF6BBA0EDA67BDE01AB9F7BFD4FE6F8BD81F63ED18A3A2D27BBD23901328951A7F629C4BEC1FF964135D5AB79C00809A2897D5F1A87A0326FF939DF58BD8F66B4BA4CFA7FCD978FDECD6DEBE0472C57CF7A0DB8AF92D730A477546B8DDC1C25AF5C4F047E41DF8C929C3874AD4127C248230DC9A5B5DCE17AAEF0C7D81D523439783B1A7F6B2D4C3788A118CB009CAB45AEA99BE9684C6A3911C7E1B14BB03EB525114CA53F890718F8FFAF61791461E8E32DAEA50ADAC41A3232563CF272C8ED3843AB82870E61CDC9FEA69CDACC4A017ECB0C3E9891D5E111DAE8146E74305BB4166986A9145F618887B58C09BBA500DEB510C81CB4C1D533B3653278A63EBD5D82E3FB047C2C7E3181682695D445047AFFCA2309FF01917FEB47236E86F60814E53BC3224781C4D0381C2C8DA36B365F1F5D674FF5ABB2F1E96697CC102EB5416171121E14F94948AC2EB4396D37C85E3849E69A7CFFCCA3071FC63276701776A41484B1E6EE0017E567AF665D87D1F19CB6E2F0CE74C106E5B17C7AEE5D11F75991D28D322D7503034564A94AE84226965BC8B5416EA569A3314D4BAD501090B088F80A74D0FD1D43427BB45D2305C9CCB6050E97B9B6B26EE3E93541E426CCC1EFAC12BEDC799EB3161AE643D66F7351522B22C52B63C69C7EDAF5BC1412C97EF4678BFD90F221C48494FBEF1DA11A941B4CFE060C698383BF3C5726D78200720D6274594BC784FCEE9A2203E41F4FA45343FE4A252312B4FE20F96107E281AE1AF35BF99001DF97BE1D75FBD2F0EF6D709865D71E9B86546167128A8E006989D3FD688E3E5F248DBBA82BA3B7DD8AD6AB7B20C0856E6A6B6377D497937516D1BB8F85BB92C23E35CE7E5BCDA55CCB130F913F325BBFCFD3487E9BF82837CC8A3E7285B188CDB197E2EA6EEC241C7651426FC162B0CEDCE99C109D8B9420F3734DB742DB9B0388763807D813A1EBA700253BC8F1797E072F374396ACBDE754C5CE86E5875FAB33F1479C6702A7B22E1056C22EC99E3435F51A5CD1519F93AA7618EE7FE3B93A3ED86E3580644251AC884784AD79CF70CBC328F7E8324FDC916670FB125468BB934E5E6D2A0237B308B31421F804EC1F631B4DB0DF14FB652E9452EEBEDB5543B381A9113B8E1A0449E6E23ECD31E856CBFA879452DBFBBC5A4C79597158A3EDDC1828AE0C32516F3BD9C5AEA8F8A607FB72A5DDB63CABB043E87881319EC1C6ACDFA333836EF44340BD389F5CF87BFB896A9433D812F227101FD62C0EA916B5D4D0C5DDF7AF5F8C4F6660BA64DA29A3BD021E380BA29E637BDCB1D2BA788FF62C48A944B515BDE2E60DC982927AD2671BAA6B558116487A774B341C2D082DF51ABC60383A48D8AF997F3532CD045E0830F714577F94B9AC8F7331E0DA637827F09A0C091F1ED5E762693409DEE31F73AC0221D2FEBBC794DD9DEDF5BC89B50FEE461A8AB89043B8039A2C6FFBAEA8DF658D823A54FF892A9169F7F5483E424E0808185F480616A48A63120EFF3C78EF73A30C9F570BDAE19B45ADFD07C34821F8BE026C520F79A1D50D049A6DFB27756AF9AF094ED67AA149A33D7CFB2088222A29EEF46AB11704D2D815CE656E599C475B868B8F5582D3B2AC73E2DB9BBA02548CC03ED2A0E01EC6C035853A79621E55FAEA3408C2D9AFBCA6B968A49BE5B788E7FDA96286B11EA1E6156D202DD3ACECD1D87794DA449639692B2DCDA1C2025E2C62FF8D5097572E490AA71B9BEE3802C71DBFC2F93446769862E7766F17E3A069D8FB9660C35E095A9BE4FEFD6B2C7D4407F82E0591BCC0AF96D417C4EC0385F086B2D3CFA330A92AF4901D402CF6143D0AB0599CDC81340809A2BAD9085197A079545B3C0630929AECF5BB008029B4714C8FF5B3855823D210D9E370AC0D4D29E89008BDA0CB8377EF03B24B60C0B50764CAB4FD7B12C3B95BB5842333253B0ACA8339DDA342AC149265B64D273A3C20CC5BF2045C21DE9F183F9A1A061DDD65E08CC4A3A7E6606FB2C2B413348EB51BE7C9E7B5FEF2A3C9E2104DB3F9F2ACC5A6D40B52DA23C6900F2E67FCA33631ABEA03FFC8AED27EB30E56DB55E121B00A363691D8627512F6CB7B82237539C3E997E5035BEC5C72932D6CA4D32D2724616FBC88CB30E7915D75DD41F888523FFD07616B8EE0BC38339D8A4B0BB969E85A09369165FC23A2EACE1A3BB2D50706F9043CD4B42E721FEE9EA4649CF4372957754589F1EA3CAB0617E9EFC82952F0343DA7BD99BAE62B0E57507168D395EBA1CB710D40793B395C220BE4799DDA4F52B0B70A24045F1F36595B27203456D42A219185008289EC9D2AECC847B1D99C9BD18669FC4730B1EE5A1BAB447D9AB71BAA3ADA472594A15CE6F1F6B2BCEB2C339BE7D608ECFC3D40581CDAD51B6AD8E862CF8BBC6ECFD911F1165D76FD611C333AA84195E40539C6FD54C7B18461FDF3BB93BB05A71FD750D24F1D971EFD676FB9D0E6926A2E9FF272E2308B0A91B1285A73F4108F7859B6293749D2C5AFB00AC168322ED74AA3B88BC0345E693C918B10CD6D7772BCF4A8D57D6F5A9CBFE6CC445C4D5681F1ED18FDC62DC2164B35E2FBBDB346E0CB88CC47AE26053C674B25F2F310DB3DB17DF35AD1CB184B62607359C7AD13135F129720EC729C3F51E10C4AF944D0DA7CC28409D429B01786ADF0FDD175509EBD2CF8A32AA2AA9844A1502017CCA84309D750A1D1D3B628E55484CE7E8348E183EDCBE8BBA9A6BB9D048EDD315045F29F7D915B3DFC8AA3D05A5B0018F212AC683B5DD5A59F64D32123F449A43A9E1DA88B300C2F21F395172673A5E61604A9B55B88CFDF869F9B82652EA0FF1287B027CB741AED49468AC9BDAD69E342A3F7D8B307D0F800E76DA058815E5A9C990D733BCA8BECFF9B2E554CD137619FA9097D6C31FCECFB426A345C8E2950A34F5090979E14B444B883762FEFBE06401895FB902DAA29B605BF9B435F7C456ECC1B68D338BAF256751BD2AEC2FD2C96793AC4E763D6FC4E399F5DE4890644DA332459CD6B340305BD7A2C52B9CDE794612B5A4D0CBE75844C029A0D47B83505BADC221EE9AC15905611A550240C9846BFF086972FE1950C9A60B831359CEF6FD3F947B7AAA279EA5D72722119FA62EEBB590D7560C88689A4091BE0065CAC26BA6C1953230C551BD49758A86F85CC70370235DBF30548D2BD83433C4924E4EDD24EFE0D18F5B78415017E4EB6433663E26A043266F993E6A3D8821B62CEB16DB789E9F3BBD9A4C227A8515B193A4C261940A0C03BFFE02CE4711074BA0D0319E7ED7A43B576B0F85436C2ACCE4819984C529AA5ECD7BDD4AC3308412FAE800B9AE94B1F2FDFF62B0382B4D92069765BD3214F5D6C4A5518CC1E5609B276D9AF94065CB087773573952CC7FEB9F981AC91ED541EE7A5CF1E5ADF1EF18C7E2722990B5979F195B2106B360FC0D6AF0FD7024FE4E29FBC13A36CABCA2CA584246D57FF4B3946731BE568C36EFA8DBAC0C2686D14C90F19721E111A26D3DA26483F733F9598F5050F62E1FCB1096B88368C90BFCFFA7879BDF45FC20FC25C04C19A24675D5A6A4C4504B1A16D5D7ED1B7178AC13D59516D2562CEEB37CEA81389DA0CC6C07093E83FCF2F6E2BB9729998D3B1A635C35C6270EE1B9C74CDA023E8A0657ABE352A488B99454BFA856D204B6FECD8D51F5902861A05D374CE9312FA8C4D2E780CACB24F9EE787268810CCB6E1393E3D20DF16D134D126652F135BB7321713CC0B50A2419B4BDABECEC95D02BFABF06A37794A017B0E42BB2113CB234EEF28E7AAF01D67F9E896B32DB4B91EF6C87619DCC10B1BD7FAF33A799821E263A81E01913BC1A4BEB42A888E701640CF3E9C309C8C473FA94499E76F99F53EB9C434547A7AD823615B145C8FA62ABC5900B78B4E7968EF90D0DDBEC0731B169A4A6DC7ED48183B96914BB1C8A0EA4022F4E079DA069FE735212DA416846BEAC94839BD70EBB2ABD12AA4FA8A196A5F5FFC7FCCC827A90ADE467AEED3827DA1CDED10B8D550CF0C5F4299C7B79E0C7255329EDE8FFBB1F1664FC46D91041046D927494D0C2DD406F996CC400340B02316590358B5F6E9D40423A069C882B0C1035F5F0052D271750DA843E5A2CE9699A052EB536C94FACDA8864BC3555EE04C57AC3F1ABAE86E6A3C5E4620591F36AFDEDF1CF4F644D70844E91E4D49423B174FF05CEAF5339ECCD48F35F77C0B25C26EB987F9B3B105C831FAB5421D78E4B0B79C8E87AAA8746DDA54D428C4EE56C8329D3C5314A902548A434D600472ECA81AC99DB97A1B32DDA265F7AAAF1C2F78FE0131EAAD1EA6881D7541A36FC840B3215EA3F3249BC59F345B375495F62202DB4111F07784ACC21D95DAC099B6EEB358E5E2D59F9366FB0AA4BC9A982DFC4857731D01A4E8CAC9B9BBD9054C7990C56500E8F904ACB2608B7EE9003D62914D85503B7E7255D9CF5A65D022CBC2DD449FC10319DB4E03DFFCE3090D4634EC62FD2E550419EB2D97F31D18129066F256444539FACB5278BC1832B9A36B93C9A6E53A30F22514640DA4B403D2FA86569A09A5E274A9975DBFF033BA9054FAD6168D3BFE6430C70EC79B4408E5B35CD73D2493CA8383910370CC572BF23D39A95BAA13A957DED71599A6A5679A3ED68DEE7115A7E93B1FB9065ABAAA152E29E886023C0F497EA577DDC58049944D3AF9C0630E625C2A56AC362DE39A8302392FF254F366B696345F6C4A999DB2CDF80409EDAE7E85E98AA86C2E29BB1F362C7E00275438D76E6D5489912019AFF026F53F323AFC96B5C8A14DEFA5011E22A3140442C71A9AE8FAE4DEF1A4B367C0026D1E23E6A3C8B15CA461541AB62E45ED4E521CBD25B520D6F4B697A561ECEB8C7ADEE12705B13D47936E206735E3678AEAB3A83C45D93E9A2AD7596102F63113B2390CBA3AB9233B12FCE3DBE69FCBFB2CD247F932CD731DF1331E560B8881EE7E2252F2E317150665FD45CE3F854A39264BDBC3EF53F2C0F5A915DF2B4451F5861EAD88AC258CBD771725E83329E276316EC3F5349988D21CDE28B47AB6DD28A7FFC6F66D57987C4921A0330162F8F0406ACBE8BBD23F021058D773D1D248EA9E164A478CCC1A7631EB9DDC8ED37BD94DB95DA70A6198EBA2384A0F6A8F8ED5A1978EDC1007D3758DAB31395706951491FA179556AE6B45126BE01560B68D38F528701FDFAE5611F05A35AA398DDE52858088EF01473F34E5B2B74D2942ADD460FC5E2E715820224A48867003E2AC81E72F00BD2C1DA6DA8CC82A5D8287B54AADAD1EBD57E315279A612865DFA2D52C47494598BFE95C70346A212A4A92C105BE9B60219B56C1C1FE817005949B78A4559E0CE4DC065F75C3AF0DA877E5FFCC89EAEB016E88BDFDBEC256A8C3E44121AE8AEA4206B9DB4C3AD052F74F2FABC2612D9C9CFD822953C7636C1D7FA4D9D9725A684E41EF8307EBEF02342A3AC974B126C48EE7BF06262A25744A20A252FA655DC61E66D01BF2395AE29F7BE13934F2D57AC41D610B32FD33CF93132EAA7BEBED92904F6FBBEC6984134DE6629B25EDD1F712C3666BAB601D02FAEF37A00E4006E762E9701F3CDAC4EDA213996C1B0386F9B025A5EEBA57A67E81D63E0D653320B835E70C6B72139607786C2CB53D56F118DBDF847CD88DE1CE344EC20AA6E9F8BAE5DD569827DB0810127A1EA184051D3F9DC317F9DF02704610DC4AD91A6B95E2F1B3F17DCDFCFAAECA20DE6EE1FB9501AE94E62A55032FE46126EEF57FC604F9D0C7C9CCCB1F83C0CFA9257481F1A290AF13A71ADA6FFE40442749E73006D09F388855DED578E6676B211CC1FD8CE2BECE8F04FD7FF9B3555353DC695F3D52E6EC163F8594160C64D7179B9C8F1FA0FBE36E060DF496EC06F24580EFB97D1F36D5E77481C1F7090A9BBE621E6D3E4113AE0C034316303EED8A2BD7D82679C8F32952BE2B10140B180FC6BB58B706C98FD15F4FD375817F44CFAA71816681A15A4EE8F5305146C0E1628F8AC9F7CF2FC453542700D7FE53ECF47A7568684AB7E7CC491CF2066281F485966AD19B992590341DF2A50D6AB3275931FDCF4AE00EFBFF474E6B65CB1C12F4753AF88BBA91BF042BFF6E998ACD485EE514D7BE7513643DF0238738D58E48669DA74D1BC15B34434C65FA6650764CB1CD5F113E2617B6FEE55F233D0891635AD5DD5CAC35700A6A298DFD21735535F777A62D5B223A346D33CB5DF5D2F546D2FB360A8B061C56CB9DBB358847B0230496DE9FCC6BAF0F5A13ACFBB7BEA0F5760EE3DF2175471E5B5A5B677C36A383A73D322D734BF78376510BA6CCD04CB303104B10D1A6C8C18D3A915CF0263FBD60648CDA7632858D8C52DA46DA49F534C1E8E2C7C30E94C07DD5F88F8603DCE5AD30E06E7597484F12AC44671F39B4D5CDA7BC216791BF58C1F559A27FAA58FFC51782ADD09ABF30257A276735CAA00C155034E7A65183615B75A505675873389D141659BA073CE942589DFAF5CA17190660381359A6946A02C1F1FD7728E742C5DCFC0C697666C4CE68B3533DBA5195F0B464FDFC098361CF31362803AD0F5E4EA7B4143DF98A961369B10326A51EEF35EA5C4EAC72AE59C977F042FC42E57B261DEFEB16D169E996E596EAA57E798C581C9A535AA208BB7B453E6EC0C775E7509A39BFE74FBDD1FF5CD02A4028600243251F2E04327E620EA80DC4F55D779BD759F7FDAFA71E4351062A94228238D78440262A43C4F8B825D380386849DF566AA35271E5165EA61B469C12A3D2EF6AF07927195A1418ACC2E6B2175FCAC1658BC0A835D3CB5101941E121B76A754C8817140FAB2A96BADFFA50494F882B46C6FE40FB4ECEEC1B5E8BDA46862EFB15BCFFE8E2A94EB43B58913D25822AADAA189621C1C0BEFA236CE7B4B265C4410EBE04F12CBBC9117641B20286FBEB4DC2CB36C20FD6529B6AC1521641DBDBD8F489832F1359A199298671B968AB86DABF1ED90EF48F7A9C6BF0124105AC7D5E0CCE9B1BBFCBAD5B5A9631D17211424DFC53FE5B9D746BFAC1D877F4FDB41D28E0F6382D8B26BEBAFF17F3A8C9CA41299FE2E0C39FAFAEFAECC5A8AE899A2D334C8E824A2856C859ACE87C4633A3F98FC735479626C9873BBC3CE8854CA179E3A6F45AC13535CCDEB7224FA8FC0C337B3212E494F37D3E4B191778367911E0FEFE1CC99DDD2914CA380C0E2EDA4812FC420F4361056D891E4F4F76E1C606C393016B95E50FA4A49C7344F5CDEA0C62B36E49DE0346B95A630F33828660CD823D29B9894DEDD898DBCD385CBC66B1E858C574AA5DFC5C1A23F535C567BED04B3F523FE598CEC3445337AB15382D570299AC66651C8D35BE4A84FBEFF8946F2AC2B5BFDF81B84FFB235F4BDC50B2BA9432125ACA3AEA34B9632DF3DDC18A48C2E985DD1C6367D843093D3028ADD0274F461E3ED362A2C5083A3F0344A4E97F892A6AE44CDF2D1F3D481DC567C5863D34E6EADF24886B1B6A0BDC88AA04460DF529F630E670243F4EABF981087667D410756D1F50CD9C95C72FE2EAE909C290018AEA4966E5FC27E11865835710E071D84AFE7A23DDC19B5C00D41D4F256951BDB8D0F02A687E8D4FF1C70692C777A013522785DB78EA251CEF3775FBF754989FB0B4BADF2D62349A757F4C7B01C2FCF6DCA91B8DD87D52207C8F5521F007337F6C5AF8F67FE05C5C6702E232720BBF0722481F27E19CEF3618C6F98D1D3242F6DC0B3DD87E51BBC287285527E27CA4B99B139F093ED8ADC9B426490DFD684E09198B6A9C3594A0A3192D8126D66248A17EF7A36F02AE536FF00983FD530D48147E0EB6F4FB0AA47F595194017BE7E025887653A7A3F035C80BA9834B3B1FB30FE0CF482B998A8C91A8EB99F7C2CD8A0D5494AB0C27472C400B4E16D0CA3C9D1C87D5317A50E01B273A3AB7B652F1A20115EAD3EDF3156A5C4992C4E1F911B559F302904F2C08EC05B2C9402FA3BD56117C1FC39713E7D2A6BE2D03AF7F95B8E53DE8781EDFA02CD00B96271565400FE999165972B79D9A331F8C51717E6E2F2ADA64C1206CA73C52536FB836F1A63186B80063F72BE479868CE7100B6B4E243316E5A9A7403CC1EACC696AAA92E1833FC98139984AC95FF6B9A24E391785F0036B9DA01575C37282E8BC13AE0144AF55A7BF522B14D1C7CCD3F8049E8B6158B6FD9444FF1B9798600392255AF7754D8B886648BDFBC8485299B205222E1D75C6D4968FC9D388B1DD22753A4DD9C9AD33BC0D9A356DFBF2D35DAA6D27BD27D829682413CE3B6E1E0BD383AA930919C4E0C038DE7A68A45741D935135037C6E117C660369220E009C0FA0781866232E649B6F56351C5B52702F2FFDB14AA0475175A664CE1D3223A18D7CC00A3E3C24C1E20280260DF4C9386337FA7508016AB780D390347539E10D4DFB6EA711C083F919D764C8E63C7D9E6EFFACA07E415102DD3DD2BF6BB4C58315584E35EC37EF02EDED8B12165D477021149438BED59612AE636397B717A08C59765CBC62EEA85257417C0E3DB38B2D9B06FF28D44370F5506DDEE240C12DC03CCDB7841097BD51A7FACA83051AD021E71A403D83D4E40DD2D13CFEC960E258507774E399DC4C551C430C79ECA9E13D69A44C362483F3A7818C3EA66EA64CDD3785C5D520CB3D8C6AD18DE70A2341AF39917932AC592C3A81B7B3B5A6D60E266198F5AF1B72782CE7395EAE905C4F6537624F864523EA4624EFEF417C6D7D839A7D9EBE2CC8041B85C86137B6C0BE9E15C5DF73BAD85B7B9E3F094E4CE365956234D77171A021CB85556F7FD770213A47FE9CCE7CA2D3539C4AE905F384DA75AEAB8C0B9D57E29003C20BD8ED19294B325964093958D3143A93E03F49724FC0A95BFDD4F9F78710A43B64145EE1AA57FEB021D92B5C35F13C6B0555AE7500185697B5E07CC81481FB20409251C45A393F17FA75697EDFA76979689F2BD6C8C3BD3752236214AE01049727F35296D9A7E405AEADEE7968C24BBDC5A87F0FCF625B87E7684D11F80E62FEAC84727FCCD98624E8B12D2E0216357B23B369E43A162C414D3A01C7A8992355CA6952DE41510539DA2CB0FB11B2DEBDE7519B76F2A830F4EBF22AF7158750652EAFC6F361E880A55B3CF1B519A11AF8020D617115A0C369AC51CBD325A82A0045E0592EC72FAE4B92C7E04A8382C085F59670586643D757D1D974A971515BFF18FECF1ACAA31FC35FB5A2283ECE8EC49D7B350D93E1A2032A8A159E7E29B949AF5211596B8CD153B7D0DF60EB14EC037ADCC89B3B61BD66CD21D65C7FDA211A0396B0A95111D94BB0F3989453C45016146AE5E288C6323EA1EE80860C503D86ABF6031470C7E489FDFAFADEE5DF6B5D9667A9B03EFFB428052B3CBDAEC5DCCF03F51DC79CA440127A4A440D80EC7EF5B4ABD1FEB42B9EDE65B352E43CB9995315D0989FAA29D12777C9968CF7805C39C6B67B0CE3C7FEEF441AE46788636002B03062FD76C9793B3B43D5F607B0FCFC7C9B0CC116470E3E866FFFDEA78CCA3ABD20F26E740E248BB4C19EA29B42A588686357F8E9DFD88E1C4EFCF9235B1E93F679123742DFABBA2D17F2CEF8F93980DFEA30D5C4ACB5692F8286CB6CBF0D86505ED129D45E881BBDE023E1BC5E7C8BB0C73D6475419A0E3A0F12EF299758FEEC7A9C8F60425986FB3E8169079F9986E0D48D9F3DE04304836CA8E460FD938A1FC3DEE5370A6DA5AAE4E667EED96616C84CD9E87FCBB460B16E3F29D1EC752EC5BAC2058D8D1698E5D80672686CAD4BB53B3683F4B5ACEA1CBD1DB1B593C48C80CD0C9994739B5FFCFB350C209E4F419C3A9CBCE444D45A77DF2E67F5EC8CCE73CA371DF1791BFFEFEDB655E7E23487AE82CEDAA181CC00C1ADB03FE0932700DF76411B5DB9287102F88837727E7F6670BE433B0A0712E2470777A46F464508E3D4C3DBB2AC60770ABB9F30C7B42CF32F4DE3B39168EA418A10984943D0D81B9D6C7637C8DBD91CD9E070E414F148318E03F04A45D69304743754B29C6827B538EB97B8D321F7C80E1F5B8B21E7FB4A6E43133534569AFBE291858F547714059068C85E202CE850016CC61F61D8B02F7502EA57EC047C5C63CCB120E7CC006EB8905D838BFC85745DF5060E3D387FB07ABC226B5D1C4006ABD0B9203B8CEA488E0C63C7991683A0D7D067F345DF5532E6BACF41DEF254CEC7AE361502BE9699AE895B1D2AF47AD3B1E16B0EA14B87A4A3EFFD6123232C6A7AF9E8CC881742DA94DA8D248875329B77F73F9A79EFB520A1100389A63D4CB9217A9FAD2801AE823C095F8A73650CEE3EBD508B2C4159E55BE3AAB6C82CDE67A9FA691D16A939AF88F1F7BF9F1F6793F339964C551E68C6EAC2CCEB30BD694C465B13E7F86B25987D28B471A9FFA5674AA802DA87D8E34E197961C5F4E1B3AAF9AECBC4CF9721DA5A1F514AEA66A432E63207B9C454FD5F02C1E8FDF79682D4E4EFC3E3713A1F1DACC9D98A93DEC82E4D4A8D84065E94FEF7F5C8F12C012BCBC93BDC1D95DF30033F33602A4318C3E971F64E97534729A127EBC93049B2844E1CA2178CD7580673F8D3B79F22F9AAE300053D61404097672F568CF4723D00586AF90F24C33ED6CFE6D03B79ACB94DF02CB4678EF0F5C11B7115B0CA9307649E16C51C6FF85912807B789F3F3514B2A294112B1A214ADF8C1DD87CAA06E03D7BB99544978BFAC8CD6D067EB491967B22BFB5DACB0B02D39DE17A4C59CA2664FA360660DB570CA0974559830A57FCA9006367BBFD27C6763235139A29868CD36C65BE76562FB68B30ED7EAE2D46BB5EF9E70FCE4F7899E55080BF4E4809911F8D315E03D6D511C892E92943E977F5C5760B88C7360B289D484F8DB34EE499F48A957BF2B56E1C536EAD1FE3CDB2CBFD458BC92940C544CB146A12F4C94119BBCCFD07F3DE47D63330D331AA1686C522A4A923CD6B141B20FA2E9C034AEFA6565FDB93A549F98A359E1B9211A50E5BE14A8D1F95C7AD9A1DE495D354188B32257FC5B4F4EB0DA2605288C9A2A09FBF058C8292E083D8583516B4B82B9A967587EC9D2DF83CE52CCF3BBA493F79F6146E68B1EBF142FE50636132EE9B00083512125A00A4AF3387C230FE67E5EC3C01DD194468FFE0FFDAB43138C74D49A327209C7FFC2EA767E49BEFDB9EFDD4B272554DC834722811F1A605ACABDC44B90E4974C171709E22EAEF6CB8A6926714229939AB7FADBBEAB27391D343D457111259AECCE365443C5F12A134D10172FA92E3B9F55062BA1016A1C58478598B74D427A1DF4DF9589371AD12458D68024B64257E1EC0B99D50E4B6C6BB9E214F93296ABB10EE5C548FAF4AC914AB120ED540DDADAB0EA7FFF348CF824C7F0D80E1DF8E197F9E644C34748AFA1F4CAC72772C76A827F7159C14BECCABB0E451D0F4548C853F70D137BE57FBCA32C5691EA712F3A6D22D0E32989F2CB398D5E0B10E85B936E8BEC5B58DF9EEF87D3486B3C4042D4909FC1BB1F26CE8E44AF01AA2E25902EEF1A845F50B4E59E85F6E7E83E394CE6DABECB15BAF0EBC90773B9BC367486945305634638575350E6015972C26B5F0E243D744B5DB04A294EA7A5EEB813D1D6764888ABEA96CA6EF7BF9D98D87B39EBA9884345CA92689E46B7C425D7F788863D520F8B48FFEBCDCD61EBA8FD868413D489EEE4DECB616710E5ECDD71C019901888773B1CDE539CC34DF84125F983FA4390C3CF3A86DA7BCD618A02B20F862394CEF44E2CEE557D302F49E0017EBD53F233A6DB1E6E3021E77C4856B7CF1E9F436CAD80BD6FB890F0002BD81C21E4AE1A69E4BFEF36D130FBDD5AC69F7D49276B54EF8BF5E6DA19518309994F556FD54F83DD0E0B8F877B768C684EAB056415647F4B9B99D1C970FED9B54B01431861412F8D200684518419B77AFEBF456DF3187457DCE111008DDB74B43DD0156673999D83091C11F90700C6391BC4E12746EC66BB721B708D04AC5F841747711553912923D22BC13F4E03AB6813673F6CACEEFEA4A0A893C2F000B0553F706B0886C61327BDA3C7197751DE0410D0B1F11FF65DD3F807637C0E0CF9F69C539B50EEAE3B4CFB2F5895DEFC4E8EFEA0180E00C525F36BD2A246652A619C963DF032B357DAF8550F5CEFD6A063A57898847173BED35F82F9AF0084400456B1BA8B744C674E409D811387EC41E20C7E003EA56DBEE7019E080A4F66BEAF5ECDA441C80FC1585D8E012F7715BDF0D219DEBB6DB9FBFC37DB557F728B000B6EDBA3384102B36F221A7D9AF04F4442D8E793FC80D4CE858736A5A2E872C68501D50AFA527720F9530EE23710D18A53DB0FE6A7F8C9CA82002894B9FCBE5574BC79509BBF66AFBE4AC4A60D1ECB7AAF968BD1A94B9E32E4FBD2B82409CD5FB4A6B8610C4E12449B0FF3B15D5AF665608440CE77D03C65586300BD9871EC9197EF42C97B7C94751FDF2D76A5472C58122E0D78198DBA5F6242E62C589DE4FD6A5EB96B1B73F35CCDA756600699ED437E89AC9015FB2A4CF64F62547B7CAA1422EA593DED13B776F60A2E2F0FB2F6A543568DEC2C7E2FC51D71F1F26C22A4B0A1DB6900616FB3D66E68AF7A63EF4D8F93F119B747141348D5E24D99026EE998C9FAEFB9619A631F8385CADC30AB85FA51653B8ACA391536B43B3E9BC2BD8644FD2B7BA2EB60066BF357D435D3E958974671FC97999BF2366E4C27FD2140862F32CDE771AEF0599D2AA04073B2FE2A5656DCF80911A09FBFBF848DC3B0F820E0055A2B9475ADBC2FF228CED013CF5DD971C5A3BECF925F2BC1B0F45C2FA46D1E198C83D8C4D48B71E9B1C21F15E08706827A8A92FC28861EBB8A1F42F89121A5B2AC6E26FBEB20433C9BF17DA1EE0B905BF8546D9F9D4662EBD3647AAD1B14FC353C6DFE9A91FA1D301FE0E9E2D7EBCCB848E3DFB027D69DA66550A2A6C9B03F414EB989B690210128F523B872FCD1F1EC4891AF64D07FF0A41C9AE344BAAD7515B815F3920E2BDF3D6716F243CE4C1F4FA4C05BF1AE69C078F811D29CA2ED8E2C806761174884F3900E9D77DC9D282E42864F8D962CE00F20CDB2C916215CB52D51D5981A6B24A32ADFB2B95C76C10ED51786860FB6E4B1D927459AAA52BAA567470FCEB0FF0A7B51EAF67&amp;device_name=GooglePixel&amp;device_platform=Android10GooglePixel&amp;device_tourist_id=24548810039087&amp;disable_rcmd=0&amp;dt=WbsDs9%2F8PG29XfRqHyF6CjeRTDMkLOy31QTjU9OySZ0hKP8amsufLr%2FyKME7FGCYxG0ct%2BMVCIBJ%0AA1arQVdiMdoVqKN3A2Xz3tJEiqUFxWoyVFEca9OEEjK05xzQVenW6zP4LRwDCQSFvQDPRt%2FUbnpt%0AZqb9PTrGtlirLBCOf20%3D%0A&amp;extend=&amp;from_pv=&amp;from_url=&amp;local_id=XUE61EAECE03D3FB36487B78EBC1F5F96E3E3&amp;login_session_id=9a8bbc6217ae96dec11c9fad20a9732b&amp;mobi_app=android&amp;password=E0d7HG3pQommdU9rclangxHzyMbQusWPV7b3vqIkMHHV0sT0hFCsTxH%2BVy5jfAg2mFaGiIRDyvob%0Ad8%2Bhpw05oTlgr1JuzcaMmQuV8tCoBB2x1kK9R8%2BHuDE26sheSWjKEubsEbShpffQcBWlBEkpjOQh%0An8Hdf3yRcjgsCSU5UUM%3D%0A&amp;platform=android&amp;s_locale=zh-Hans_CN&amp;spm_id=main.homepage.bottombar.myinfo&amp;statistics=%7B%22appId%22%3A1%2C%22platform%22%3A3%2C%22version%22%3A%228.42.0%22%2C%22abtest%22%3A%22%22%7D&amp;ts=1745591810&amp;username=15982339904&amp;sign=17a949bd74918fade743ec7c5527b304\n\nJAVA层逆向\n搜索/x/passport-login/oauth2/login定位到关键接口\n\n\n\n大部分的参数都在这里了，唯独没有看到sign, 那sign应该是后续添加进去的。回到前面的地方，这里可以看到大部分请求都会经过拦截器AuthInterceptor\n\n进入AuthInterceptor类，其中signedQuery方法十分可疑，返回了一个SignedQuery对象，跟进去看看这个类。\n\n用frida hook验证发现这正是我们想要的sign，交叉引用却找不到在哪里调用，那就用frida查看堆栈调用。\n\n\n根据调用堆栈我们发现，SignedQuery的构造方法是在Native层调用的，也就是说sign是在Libbili.s方法中生成的。LibBili.s位于动态库libbili.so中。\n\nnative逆向\n.init_array中的函数用于异或还原被加密的字符串，直接用解密后的数据覆盖掉就好了。在JNI_OnLoad找到动态注册的jni函数\n\n\ns函数最后返回了一个SignedQuery对象，SignedQuery构造方法中的两个参数就是在这里传入的。\n\nsub_18FF0就是我们要找的生成sign的函数，使用frida hook的结果如下，第一个参数是sign的缓冲区，第二个是要签名的数据data，第三个是数据的长度，最后一个参数p是根据appkey来生成的16个字节的数据p。\n\nunidbg主动调用生成sign\n前面已经得到了加密算法的参数，借助unidbg我们可以主动调用sub_18FF0生成sign。\n\npackage com.bilbil.sign;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.Module;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.*;import com.github.unidbg.linux.android.dvm.jni.ProxyClassFactory;import com.github.unidbg.linux.android.dvm.jni.ProxyDvmObject;import com.github.unidbg.memory.Memory;import com.github.unidbg.memory.MemoryBlock;import com.github.unidbg.pointer.UnidbgPointer;import java.io.File;import java.io.IOException;import java.nio.charset.Charset;import java.util.ArrayList;import java.util.List;public class x2d1 extends AbstractJni &#123;    //unidbg模拟器    private final AndroidEmulator emulator;    //Dalvik虚拟机    private final VM vm;    private final DalvikModule dm;    private final Module module;    public x2d1() &#123;        //创建64android模拟器实例        emulator = AndroidEmulatorBuilder.for64Bit()                .setProcessName(&quot;tv.danmaku.bili&quot;)                .build();        //获取内存管理器        Memory memory = emulator.getMemory();        //设置android api版本 只能是23否则报错        memory.setLibraryResolver(new AndroidResolver(23));        //获取dalvik虚拟机        vm = emulator.createDalvikVM(new File(&quot;unidbg-android/src/test/resources/example_binaries/android_lib/bilibili.so&quot;));        //调用java方法时可以继续执行        //vm.setDvmClassFactory(new ProxyClassFactory());        //开启log        vm.setJni(this);        vm.setVerbose(true);        //加载so        dm = vm.loadLibrary(new File(&quot;unidbg-android/src/test/resources/example_binaries/android_lib/libbili.so&quot;),                false);        module = dm.getModule();        dm.callJNI_OnLoad(emulator);    &#125;    public void destroy() throws IOException &#123;        emulator.close();    &#125;    private static String bytesToString(byte[] bytes) &#123;        StringBuilder sb = new StringBuilder();        for (byte b : bytes) &#123;            sb.append((char)b);        &#125;        return sb.toString();    &#125;    public void call_sign(String data,byte[] p_data)&#123;        int data_len = data.length();        Memory memory = emulator.getMemory();            //获取内存操作接口        MemoryBlock sign = memory.malloc(33,false);    //申请空间        UnidbgPointer sign_ptr = sign.getPointer();          //获取指针        MemoryBlock data_block = memory.malloc(data_len,false);        UnidbgPointer data_ptr = data_block.getPointer();        data_ptr.write(data.getBytes());        MemoryBlock p = memory.malloc(17,false);        UnidbgPointer p_ptr = p.getPointer();        p_ptr.write(p_data);        //传参        List&lt;Object&gt; args = new ArrayList&lt;Object&gt;();        args.add(sign_ptr);        args.add(data_ptr);        args.add(data_len);        args.add(p_ptr);        module.callFunction(emulator, 0x18FF0, args.toArray());        byte[] output = sign_ptr.getByteArray(0,0x20);        String Sign = bytesToString(output);        System.out.println(&quot;sign=0x&quot;+ Sign);    &#125;    public static void main(String[] args) throws IOException &#123;        x2d1 x2d1 = new x2d1();        byte[] p = new byte[] &#123;(byte)0xcc,0x52,0x0c,0x56,(byte)0xd0,(byte)0xfe,(byte)0x88,(byte)0xd2,(byte)0xd1,(byte)0x9e,(byte)0x85,0x45,0x73,(byte)0xd9,(byte)0xff,(byte)0x8b&#125;;        String data = &quot;access_key=bb65940d751c90359ebe2d466ece6541CjAvuTqJd7FENl2tpRvB-jzJ403-VVFM7KNe0tt319UeIwA7PgrmQqzDJ7ilEkZI12ISVndfdXUwOHZsR1FqRWVQWjBVc2wwaC1VRUctR0lRVlBMaGVISTJIZ0VrWnRtNXkwWHhBOGxoN1J4dnRSRnhhNGNfZ1gxbXl0TmU0ZEJxSnp2OUZYT1ZBIIEC&amp;appkey=1d8b6e7d45233436&amp;build=8420400&amp;c_locale=zh-Hans_CN&amp;channel=html5_share_source_qqchat&amp;device=phone&amp;disable_rcmd=0&amp;mobi_app=android&amp;network=wifi&amp;platform=android&amp;s_locale=zh-Hans_CN&amp;screen_height=1794&amp;screen_width=1080&amp;selected=&amp;statistics=%7B%22appId%22%3A1%2C%22platform%22%3A3%2C%22version%22%3A%228.42.0%22%2C%22abtest%22%3A%22%22%7D&amp;ts=1745846090&quot;;        x2d1.call_sign(data,p);        x2d1.destroy();    &#125;&#125;\n\n\n算法还原\n__int64 __fastcall sub_18FF0(__int64 sign, char *data, __int64 len_1, int *salt)&#123;  unsigned int len; // w21  int i; // w25  __int64 result; // x0  int j; // w28  _DWORD delta[22]; // [xsp+48h] [xbp-C8h] BYREF  char output[24]; // [xsp+A0h] [xbp-70h] BYREF  __int64 v13; // [xsp+B8h] [xbp-58h]  len = len_1;  v13 = *(_ReadStatusReg(TPIDR_EL0) + 40);  memset(output, 0, sizeof(output));  memset(delta, 0, sizeof(delta));  sub_FFAC(delta);               //init delta  sub_FFC0(delta, data, len);  for ( i = 0; i &lt; 4; ++i )  &#123;    sprintf(output, &quot;%08x&quot;, salt[i]);   //    sub_FFC0(delta, output, 8u);  &#125;  result = sub_12DD0(output, delta);  for ( j = 0; j &lt; 16; ++j )    result = sprintf((sign + 2LL * j), &quot;%02x&quot;, output[j]);  return result;&#125;\n\n在sub_FFAC中找到了MD5的常数，猜测传入的十六字节数据应该是salt，和数据拼起来计算MD5\n\nCyberChef验证一下，完全正确\n\n\n总结\napp似乎没有对抓包进行检测，很容易就抓到包，对frida的检测使用了libmsaoaidsec.so，这个已经被逆烂了。java层也没有什么混淆，直接就定位到了关键的方法。最后Native层虽然有OLLVM混淆，但是大部分可以用插件去掉。\n\n\n\n最后贴下frida脚本\nfunction hook_dlopen()&#123;    var detect_so = &quot;libmsaoaidsec.so&quot;;    var dump_so = &quot;libbili.so&quot;;    Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;), &#123;        onEnter: function(args) &#123;            if(args[0] != null)&#123;                console.log(&#x27;dlopen called with filename: &#x27; + Memory.readUtf8String(args[0]));            &#125;            this.pass = 0;            this.dump = 0;            if(Memory.readUtf8String(args[0]).indexOf(detect_so) != -1)&#123;                console.log(&quot;libmsaoaidsec.so loaded&quot;);                args[0] = Memory.allocUtf8String(&quot;libc.so&quot;);                this.pass = 1;            &#125;        &#125;,        onLeave: function(retval)&#123;            if(this.pass == 1)&#123;                //dump(dump_so);                //hook_javaMethod();                this.pass = 0;            &#125;            console.log(&quot;return&quot;);            return retval;      &#125;    &#125;    );&#125;// function dump(filename)&#123;//     var handle = Process.getModuleByName(filename);//     console.log(&quot;[dumping...........]&quot;);//     var path = &quot;/data/data/tv.danmaku.bili/&quot; + handle.name + &quot;_&quot; + handle.base + &quot;_&quot; + ptr(handle.size) + &quot;.so&quot;;//     var file_handle = new File(path, &quot;wb&quot;);//     if(!file_handle) &#123;//         console.log(&quot;[dump] failed to open file&quot;);//     &#125;//         Memory.protect(ptr(handle.base), handle.size, &#x27;rwx&#x27;);//         var libbuffer = ptr(handle.base).readByteArray(handle.size);//         file_handle.write(libbuffer);//         file_handle.close();//         console.log(&quot;[dump] finished path is &quot; + path);//     &#125;function hook_javaMethod()&#123;    Java.perform(function()&#123;            let BiliPassportApi = Java.use(&quot;com.bilibili.lib.accounts.BiliPassportApi&quot;);            BiliPassportApi[&quot;M&quot;].implementation = function (str, str2, map, str3, str4, str5, str6, str7, str8, deviceMetaDelegate) &#123;            console.log(map.$className);                                    console.log(`BiliPassportApi.M is called: str=$&#123;str&#125;, str2=$&#123;str2&#125;, map=$&#123;map&#125;, str3=$&#123;str3&#125;, str4=$&#123;str4&#125;, str5=$&#123;str5&#125;, str6=$&#123;str6&#125;, str7=$&#123;str7&#125;, str8=$&#123;str8&#125;, deviceMetaDelegate=$&#123;deviceMetaDelegate&#125;`);            let result = this[&quot;M&quot;](str, str2, map, str3, str4, str5, str6, str7, str8, deviceMetaDelegate);            console.log(`BiliPassportApi.M result=$&#123;result&#125;`);            return result;        &#125;;//         let PassportCommParams = Java.use(&quot;com.bilibili.lib.accounts.PassportCommParams&quot;);//         PassportCommParams[&quot;attachDeviceParams&quot;].implementation = function (map) &#123;//         let result = this[&quot;attachDeviceParams&quot;](map);//         let josnmap = Java.cast(result,Java.use(&quot;java.util.HashMap&quot;));//         console.log(josnmap);//         return result;// &#125;;            let SignedQuery = Java.use(&quot;com.bilibili.nativelibrary.SignedQuery&quot;);            SignedQuery[&quot;$init&quot;].implementation = function (str, str2) &#123;            console.log(`SignedQuery.$init is called: str=$&#123;str&#125;, str2=$&#123;str2&#125;\\n`);            //showStacks();            this[&quot;$init&quot;](str, str2);&#125;;     let LibBili = Java.use(&quot;com.bilibili.nativelibrary.LibBili&quot;);//     LibBili[&quot;signQuery&quot;].overload(&#x27;java.util.Map&#x27;).implementation = function (map) &#123;//     console.log(`LibBili.signQuery is called: map=$&#123;map&#125;`);//     let result = this[&quot;signQuery&quot;](map);//     console.log(`LibBili.signQuery result=$&#123;result&#125;`);//     return result;// &#125;;    LibBili[&quot;s&quot;].implementation = function (sortedMap) &#123;    console.log(`LibBili.s is called: sortedMap=$&#123;sortedMap&#125;`);    let result = this[&quot;s&quot;](sortedMap);    console.log(`LibBili.s result=$&#123;result&#125;`);    return result;&#125;;    let AuthInterceptor = Java.use(&quot;com.bilibili.lib.accounts.AuthInterceptor&quot;);    AuthInterceptor[&quot;b&quot;].implementation = function () &#123;    console.log(`AuthInterceptor.b is called`);    let result = this[&quot;b&quot;]();    console.log(`AuthInterceptor.b result=$&#123;result&#125;`);    return result;&#125;;    &#125;);&#125;function showStacks() &#123;   //用来查看堆栈信息    console.log(    Java.use(&quot;android.util.Log&quot;)    .getStackTraceString(    Java.use(&quot;java.lang.Throwable&quot;).$new()    )    );    &#125;function hook_native()&#123;    var base = Module.findBaseAddress(&quot;libbili.so&quot;);    if(base)&#123;        var sub_18FF0 = base.add(0x18FF0);        Interceptor.attach(sub_18FF0,&#123;            onEnter:function(args)&#123;                console.log(&quot;sub_18FF0 called&quot;);                this.sign = args[0];                this.data = args[1];                this.salt = args[3];                console.log(&quot;str2 = &quot; + Memory.readCString(this.data));                console.log(&quot;salt = &quot; + byte2hexString(this.salt,16) + &quot;\\n&quot;);            &#125;,            onLeave:function(retval)&#123;                console.log(&quot;sub_18FF0 return&quot;);                console.log(&quot;sign = &quot; + Memory.readCString(this.sign));            &#125;        &#125;);        var sub_15C10 = base.add(0x15C10);        Interceptor.attach(sub_15C10,&#123;            onEnter:function(args)&#123;                //console.log(&quot;sub_15C10 called&quot;);            &#125;,            onLeave:function(retval)&#123;                this.retval = retval;                var pointer = Memory.readPointer(this.retval);                console.log(&quot;sub_15C10 ret &quot; + Memory.readCString(pointer));                //console.log(&quot;sub_15C10 return&quot;);            &#125;        &#125;);        var sub_FFC0 = base.add(0xFFC0);        Interceptor.attach(sub_FFC0,&#123;            onEnter:function(args)&#123;                this.input = args[0];                this.data = args[1];                console.log(&quot;sub_FFC0 before args[0]=&quot; + byte2hexString(this.input,16) + &quot;\\n&quot;);                console.log(&quot;sub_FFC0 before args[1]=&quot; + Memory.readCString(this.data) + &quot;\\n&quot;);                //console.log(&quot;sub_FFC0 called&quot;);            &#125;,            onLeave:function(retval)&#123;                console.log(&quot;sub_FFC0 after args[0]=&quot; + byte2hexString(this.input,16) + &quot;\\n&quot;);                                //console.log(&quot;sub_FFC0 return&quot;);            &#125;        &#125;);    &#125;    &#125;function byte2hexString(ptr,len)&#123;        var hexString = &quot;&quot;;        for (var i = 0; i &lt; len; i++) &#123;            var byte = Memory.readU8(ptr.add(i));            hexString += (&#x27;0&#x27; + byte.toString(16)).slice(-2);        &#125;        return hexString;&#125;setImmediate(hook_dlopen);//setImmediate(hook_javaMethod);setImmediate(hook_native);\n\n\n\n\n\n\n\n","categories":["逆向"],"tags":["android逆向","协议分析"]}]